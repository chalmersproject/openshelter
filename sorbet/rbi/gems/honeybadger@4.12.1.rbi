# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `honeybadger` gem.
# Please instead update this file by running `bin/tapioca gem honeybadger`.

# Honeybadger's public API is made up of two parts: the {Honeybadger} singleton
# module, and the {Agent} class. The singleton module delegates its methods to
# a global agent instance, {Agent#instance}; this allows methods to be accessed
# directly, for example when calling +Honeybadger.notify+:
#
#   begin
#     raise 'testing an error report'
#   rescue => err
#     Honeybadger.notify(err)
#   end
#
# Custom agents may also be created by users who want to report to multiple
# Honeybadger projects in the same app (or have fine-grained control over
# configuration), however most users will use the global agent.
#
# @see Honeybadger::Agent
module Honeybadger
  extend ::Forwardable
  extend ::Honeybadger

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#add_breadcrumb
  def add_breadcrumb(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#backtrace_filter
  def backtrace_filter(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#breadcrumbs
  def breadcrumbs(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#check_in
  def check_in(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#clear!
  def clear!(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @api private
  # @see Agent#config
  def config(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#configure
  def configure(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#context
  def context(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#exception_filter
  def exception_filter(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#exception_fingerprint
  def exception_fingerprint(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#flush
  def flush(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#get_context
  def get_context(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @api private
  # @see Agent#init!
  def init!(*args, **_arg1, &block); end

  # @api private
  def install_at_exit_callback; end

  # @api private
  def load_plugins!; end

  # Forwards to {Agent.instance}.
  #
  # @see Agent#notify
  def notify(exception_or_opts, opts = T.unsafe(nil)); end

  # @deprecated
  # @raise [NoMethodError]
  def start(config = T.unsafe(nil)); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#stop
  def stop(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @see Agent#track_deployment
  def track_deployment(*args, **_arg1, &block); end

  # Forwards to {Honeybadger::Agent.instance}.
  #
  # @api private
  # @see Agent#with_rack_env
  def with_rack_env(*args, **_arg1, &block); end

  private

  # @api private
  # @return [Boolean]
  def ignored_exception?(exception); end
end

# The Honeybadger agent contains all the methods for interacting with the
# Honeybadger service. It can be used to send notifications to multiple
# projects in large apps. The global agent instance ({Agent.instance}) should
# always be accessed through the {Honeybadger} singleton.
#
# === Context
#
# Context is global by default, meaning agents created via
# +Honeybadger::Agent.new+ will share context (added via
# +Honeybadger.context+ or {Honeybadger::Agent#context}) with other agents.
# This also includes the Rack environment when using the
# {Honeybadger::Rack::ErrorNotifier} middleware. To localize context for a
# custom agent, use the +local_context: true+ option when initializing.
#
# @example
#
#   # Standard usage:
#   OtherBadger = Honeybadger::Agent.new
#
#   # With local context:
#   OtherBadger = Honeybadger::Agent.new(local_context: true)
#
#   OtherBadger.configure do |config|
#   config.api_key = 'project api key'
#   end
#
#   begin
#   # Risky operation
#   rescue => e
#   OtherBadger.notify(e)
#   end
class Honeybadger::Agent
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @return [Agent] a new instance of Agent
  def initialize(opts = T.unsafe(nil)); end

  # Appends a breadcrumb to the trace. Use this when you want to add some
  # custom data to your breadcrumb trace in effort to help debugging. If a
  # notice is reported to Honeybadger, all breadcrumbs within the execution
  # path will be appended to the notice. You will be able to view the
  # breadcrumb trace in the Honeybadger interface to see what events led up
  # to the notice.
  #
  # @example
  #   Honeybadger.add_breadcrumb("Email Sent", metadata: { user: user.id, message: message })
  # @option params
  # @option params
  # @param message [String] The message you want to send with the breadcrumb
  # @param params [Hash] extra options for breadcrumb building
  # @return self
  def add_breadcrumb(message, metadata: T.unsafe(nil), category: T.unsafe(nil)); end

  # @api private
  # @see Config#backend
  def backend(*args, **_arg1, &block); end

  # DEPRECATED: Callback to filter backtrace lines. One use for this is to make
  # additional [PROJECT_ROOT] or [GEM_ROOT] substitutions, which are used by
  # Honeybadger when grouping errors and displaying application traces.
  #
  # @example
  #   Honeybadger.backtrace_filter do |line|
  #   line.gsub(/^\/my\/unknown\/bundle\/path/, "[GEM_ROOT]")
  #   end
  # @yieldparam line [String] The backtrace line to modify.
  # @yieldreturn [String] The new (modified) backtrace line.
  def backtrace_filter(*args, **_arg1, &block); end

  # Direct access to the Breadcrumbs::Collector instance
  #
  # @api private
  def breadcrumbs; end

  # Perform a synchronous check_in.
  #
  # @example
  #   Honeybadger.check_in('1MqIo1')
  # @param id [String] The unique check in id (e.g. '1MqIo1') or the check in url.
  # @return [Boolean] true if the check in was successful and false
  #   otherwise.
  def check_in(id); end

  # Clear all transaction scoped data.
  def clear!; end

  # @api private
  def config; end

  # Configure the Honeybadger agent via Ruby.
  #
  # @example
  #   Honeybadger.configure do |config|
  #   config.api_key = 'project api key'
  #   config.exceptions.ignore += [CustomError]
  #   end
  # @yield [Config::Ruby] configuration object.
  def configure(*args, **_arg1, &block); end

  # Save global context for the current request.
  #
  # @example
  #   Honeybadger.context({my_data: 'my value'})
  #
  #   # Inside a Rails controller:
  #   before_action do
  #   Honeybadger.context({user_id: current_user.id})
  #   end
  #
  #   # Explicit conversion
  #   class User < ActiveRecord::Base
  #   def to_honeybadger_context
  #   { user_id: id, user_email: email }
  #   end
  #   end
  #
  #   user = User.first
  #   Honeybadger.context(user)
  #
  #   # Clearing global context:
  #   Honeybadger.context.clear!
  # @option context
  # @option context
  # @option context
  # @param context [Hash] A Hash of data which will be sent to Honeybadger
  #   when an error occurs. If the object responds to +#to_honeybadger_context+,
  #   the return value of that method will be used (explicit conversion). Can
  #   include any key/value, but a few keys have a special meaning in
  #   Honeybadger.
  # @return [self] so that method calls can be chained.
  def context(context = T.unsafe(nil)); end

  # DEPRECATED: Callback to ignore exceptions.
  #
  # See public API documentation for {Honeybadger::Notice} for available attributes.
  #
  # @example
  #   # Ignoring based on error message:
  #   Honeybadger.exception_filter do |notice|
  #   notice.error_message =~ /sensitive data/
  #   end
  #
  #   # Ignore an entire class of exceptions:
  #   Honeybadger.exception_filter do |notice|
  #   notice.exception.class < MyError
  #   end
  # @yieldreturn [Boolean] true (to ignore) or false (to send).
  def exception_filter(*args, **_arg1, &block); end

  # DEPRECATED: Callback to add a custom grouping strategy for exceptions. The return
  # value is hashed and sent to Honeybadger. Errors with the same fingerprint
  # will be grouped.
  #
  # See public API documentation for {Honeybadger::Notice} for available attributes.
  #
  # @example
  #   Honeybadger.exception_fingerprint do |notice|
  #   [notice.error_class, notice.component, notice.backtrace.to_s].join(':')
  #   end
  # @yieldreturn [#to_s] The fingerprint of the error.
  def exception_fingerprint(*args, **_arg1, &block); end

  # Flushes all data from workers before returning. This is most useful in
  # tests when using the test backend, where normally the asynchronous nature
  # of this library could create race conditions.
  #
  # @example
  #   # Without a block:
  #   it "sends a notification to Honeybadger" do
  #   expect {
  #   Honeybadger.notify(StandardError.new('test backend'))
  #   Honeybadger.flush
  #   }.to change(Honeybadger::Backend::Test.notifications[:notices], :size).by(0)
  #   end
  #
  #   # With a block:
  #   it "sends a notification to Honeybadger" do
  #   expect {
  #   Honeybadger.flush do
  #   49.times do
  #   Honeybadger.notify(StandardError.new('test backend'))
  #   end
  #   end
  #   }.to change(Honeybadger::Backend::Test.notifications[:notices], :size).by(49)
  #   end
  # @return [Object, Boolean] value of block if block is given, otherwise true
  #   on success or false if Honeybadger isn't running.
  # @yield An optional block to execute (exceptions will propagate after
  #   data is flushed).
  def flush; end

  # Get global context for the current request.
  #
  # @example
  #   Honeybadger.context({my_data: 'my value'})
  #   Honeybadger.get_context # => {my_data: 'my value'}
  # @return [Hash, nil]
  def get_context; end

  # @api private
  # @see Config#init!
  def init!(*args, **_arg1, &block); end

  # Sends an exception to Honeybadger. Does not report ignored exceptions by
  # default.
  #
  # @example
  #   # With an exception:
  #   begin
  #   fail 'oops'
  #   rescue => exception
  #   Honeybadger.notify(exception, context: {
  #   my_data: 'value'
  #   }) # => '-1dfb92ae-9b01-42e9-9c13-31205b70744a'
  #   end
  #
  #   # Custom notification:
  #   Honeybadger.notify('Something went wrong.', {
  #   error_class: 'MyClass',
  #   context: {my_data: 'value'}
  #   }) # => '06220c5a-b471-41e5-baeb-de247da45a56'
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param exception_or_opts [Exception, Hash, Object] An Exception object,
  #   or a Hash of options which is used to build the notice. All other types
  #   of objects will be converted to a String and used as the :error_message.
  # @param opts [Hash] The options Hash when the first argument is an Exception.
  # @return [String] UUID reference to the notice within Honeybadger.
  # @return [false] when ignored.
  def notify(exception_or_opts, opts = T.unsafe(nil)); end

  # Stops the Honeybadger service.
  #
  # @example
  #   Honeybadger.stop # => nil
  def stop(force = T.unsafe(nil)); end

  # Track a new deployment
  #
  # @example
  #   Honeybadger.track_deployment(revision: 'be2ceb6')
  # @param :environment [String] The environment name. Defaults to the current configured environment.
  # @param :revision [String] The VCS revision being deployed. Defaults to the currently configured revision.
  # @param :local_username [String] The name of the user who performed the deploy.
  # @param :repository [String] The base URL of the VCS repository. It should be HTTPS-style.
  # @return [Boolean] true if the deployment was successfully tracked and false
  #   otherwise.
  def track_deployment(environment: T.unsafe(nil), revision: T.unsafe(nil), local_username: T.unsafe(nil), repository: T.unsafe(nil)); end

  # @api private
  def with_rack_env(rack_env, &block); end

  # @api private
  def worker; end

  private

  def context_manager; end
  def init_worker; end
  def push(object); end
  def send_now(object); end

  # @raise [ArgumentError]
  def validate_notify_opts!(opts); end

  def with_error_handling; end

  class << self
    # @api private
    def instance; end

    # @api private
    def instance=(instance); end
  end
end

# Binding#source_location was added in Ruby 2.6.
#
# @api private
Honeybadger::BINDING_HAS_SOURCE_LOCATION = T.let(T.unsafe(nil), TrueClass)

# @api private
module Honeybadger::Backend
  class << self
    # @api private
    def for(backend); end

    # @api private
    def mapping; end
  end
end

# @api private
class Honeybadger::Backend::BackendError < ::StandardError; end

class Honeybadger::Backend::Base
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @return [Base] a new instance of Base
  def initialize(config); end

  # Does a check in using the input id.
  #
  # @param id [String] The unique check_in id.
  # @raise NotImplementedError
  def check_in(id); end

  # Process payload for feature.
  #
  # @example
  #   backend.notify(:notices, Notice.new(...))
  # @param feature [Symbol] The feature name (corresponds to HTTP
  #   endpoint). Current options are: `:notices`, `:deploys`, `:ping`.
  # @param payload [#to_json] The JSON payload to send.
  # @raise NotImplementedError
  def notify(feature, payload); end

  # Track a deployment
  #
  # @example
  #   backend.track_deployment({ revision: 'be2ceb6' })
  # @param payload [#to_json] The JSON payload containing all deployment data.
  def track_deployment(payload); end

  private

  # Returns the value of attribute config.
  def config; end
end

# Logs the notice payload rather than sending it. The purpose of this
# backend is primarily for programmatically inspecting JSON payloads in
# integration tests.
class Honeybadger::Backend::Debug < ::Honeybadger::Backend::Null
  def check_in(id); end
  def notify(feature, payload); end
end

class Honeybadger::Backend::Null < ::Honeybadger::Backend::Base
  # @return [Null] a new instance of Null
  def initialize(*args); end

  def check_in(id); end
  def notify(feature, payload); end
end

class Honeybadger::Backend::Null::StubbedResponse < ::Honeybadger::Backend::Response
  # @return [StubbedResponse] a new instance of StubbedResponse
  def initialize; end

  # @return [Boolean]
  def success?; end
end

class Honeybadger::Backend::Response
  # Initializes the Response instance.
  #
  # @overload initialize
  # @overload initialize
  # @return [Response] a new instance of Response
  def initialize(*args); end

  # Returns the value of attribute body.
  def body; end

  # Returns the value of attribute code.
  def code; end

  # Returns the value of attribute error.
  def error; end

  def error_message; end

  # Returns the value of attribute message.
  def message; end

  # @return [Boolean]
  def success?; end

  private

  def parse_error(body); end
end

Honeybadger::Backend::Response::FRIENDLY_ERRORS = T.let(T.unsafe(nil), Hash)
Honeybadger::Backend::Response::NOT_BLANK = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Backend::Server < ::Honeybadger::Backend::Base
  # @return [Server] a new instance of Server
  def initialize(config); end

  # Does a check in using the input id.
  #
  # @param id [String] The unique check_in id.
  # @return [Response]
  def check_in(id); end

  # Post payload to endpoint for feature.
  #
  # @param feature [Symbol] The feature which is being notified.
  # @param payload [#to_json] The JSON payload to send.
  # @return [Response]
  def notify(feature, payload); end

  private

  def payload_headers(payload); end
end

Honeybadger::Backend::Server::CHECK_IN_ENDPOINT = T.let(T.unsafe(nil), String)
Honeybadger::Backend::Server::ENDPOINTS = T.let(T.unsafe(nil), Hash)
Honeybadger::Backend::Server::HTTP_ERRORS = T.let(T.unsafe(nil), Array)

class Honeybadger::Backend::Test < ::Honeybadger::Backend::Null
  def check_in(id); end
  def check_ins; end
  def notifications; end
  def notify(feature, payload); end

  class << self
    # The check in list.
    #
    # @api public
    # @example
    #   Test.check_ins # => ["foobar", "danny", ...]
    # @return [Array<Object>] List of check ins.
    def check_ins; end

    # The notification list.
    #
    # @example
    #   Test.notifications[:notices] # => [Notice, Notice, ...]
    # @return [Hash] Notifications hash.
    def notifications; end
  end
end

# Front end to parsing the backtrace for each notice.
#
# @api private
class Honeybadger::Backtrace
  # @api private
  # @return [Backtrace] a new instance of Backtrace
  def initialize(lines); end

  # @api private
  def ==(other); end

  # Holder for an Array of Backtrace::Line instances.
  #
  # @api private
  def application_lines; end

  # JSON support.
  #
  # Returns JSON representation of backtrace.
  #
  # @api private
  def as_json(options = T.unsafe(nil)); end

  # @api private
  def inspect; end

  # Holder for an Array of Backtrace::Line instances.
  #
  # @api private
  def lines; end

  # Convert Backtrace to arry.
  #
  # Returns array containing backtrace lines.
  #
  # @api private
  def to_a; end

  # Convert Backtrace to arry.
  #
  # Returns array containing backtrace lines.
  #
  # @api private
  def to_ary; end

  # Creates JSON.
  #
  # Returns valid JSON representation of backtrace.
  #
  # @api private
  def to_json(*a); end

  # @api private
  def to_s; end

  private

  # @api private
  def application_lines=(_arg0); end

  # @api private
  def lines=(_arg0); end

  class << self
    # @api private
    def parse(ruby_backtrace, opts = T.unsafe(nil)); end

    # @api private
    def split_multiline_backtrace(backtrace); end
  end
end

# Handles backtrace parsing line by line.
#
# @api private
class Honeybadger::Backtrace::Line
  # @api private
  # @return [Line] a new instance of Line
  def initialize(file, number, method, filtered_file = T.unsafe(nil), filtered_number = T.unsafe(nil), filtered_method = T.unsafe(nil), source_radius = T.unsafe(nil)); end

  # @api private
  def ==(other); end

  # Determines if this line is part of the application trace or not.
  #
  # @api private
  # @return [Boolean]
  def application?; end

  # The file portion of the line (such as app/models/user.rb).
  #
  # @api private
  def file; end

  # Filtered representations
  #
  # @api private
  def filtered_file; end

  # Filtered representations
  #
  # @api private
  def filtered_method; end

  # Filtered representations
  #
  # @api private
  def filtered_number; end

  # @api private
  def inspect; end

  # The method of the line (such as index).
  #
  # @api private
  def method; end

  # The line number portion of the line.
  #
  # @api private
  def number; end

  # @api private
  def source; end

  # Reconstructs the line in a readable fashion.
  #
  # @api private
  def to_s; end

  private

  # @api private
  def file=(_arg0); end

  # @api private
  def filtered_file=(_arg0); end

  # @api private
  def filtered_method=(_arg0); end

  # @api private
  def filtered_number=(_arg0); end

  # Open source file and read line(s).
  #
  # Returns an array of line(s) from source file.
  #
  # @api private
  def get_source(file, number, radius = T.unsafe(nil)); end

  # @api private
  def method=(_arg0); end

  # @api private
  def number=(_arg0); end

  # @api private
  def source_radius; end

  # @api private
  def source_radius=(_arg0); end

  class << self
    # Parses a single line of a given backtrace
    #
    # @api private
    # @param unparsed_line [String] The raw line from +caller+ or some backtrace.
    # @return The parsed backtrace line.
    def parse(unparsed_line, opts = T.unsafe(nil)); end
  end
end

# Backtrace line regexp (optionally allowing leading X: for windows support).
#
# @api private
Honeybadger::Backtrace::Line::INPUT_FORMAT = T.let(T.unsafe(nil), Regexp)

module Honeybadger::Breadcrumbs; end

class Honeybadger::Breadcrumbs::ActiveSupport
  class << self
    def default_notifications; end

    private

    def active_record_connection_db_config; end
  end
end

class Honeybadger::Breadcrumbs::Breadcrumb
  include ::Comparable

  # @return [Breadcrumb] a new instance of Breadcrumb
  def initialize(category: T.unsafe(nil), message: T.unsafe(nil), metadata: T.unsafe(nil)); end

  def <=>(other); end

  # Returns the value of attribute active.
  def active; end

  # Sets the attribute active
  #
  # @param value the value to set the attribute active to.
  def active=(_arg0); end

  # Is the Breadcrumb active or not. Inactive Breadcrumbs not be included
  # with any outgoing payloads.
  #
  # @return [Boolean]
  def active?; end

  # Raw breadcrumb data structure
  def category; end

  # Sets the breadcrumb to inactive
  #
  # @return self
  def ignore!; end

  # Returns the value of attribute message.
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  def message=(_arg0); end

  # Returns the value of attribute metadata.
  def metadata; end

  # Sets the attribute metadata
  #
  # @param value the value to set the attribute metadata to.
  def metadata=(_arg0); end

  # Raw breadcrumb data structure
  def timestamp; end

  def to_h; end
end

class Honeybadger::Breadcrumbs::Collector
  include ::Enumerable
  extend ::Forwardable

  # @return [Collector] a new instance of Collector
  def initialize(config, buffer = T.unsafe(nil)); end

  # Add Breadcrumb to stack
  #
  # @return [self] Filtered breadcrumbs
  def <<(breadcrumb); end

  # Add Breadcrumb to stack
  #
  # @return [self] Filtered breadcrumbs
  def add!(breadcrumb); end

  def clear!(*args, **_arg1, &block); end

  # Removes the prevous breadcrumb from the buffer if the supplied
  # block returns a falsy value
  #
  # @api private
  def drop_previous_breadcrumb_if; end

  def each(*args, **_arg1, &block); end
  def previous(*args, **_arg1, &block); end
  def to_a(*args, **_arg1, &block); end
  def to_h; end

  # All active breadcrumbs you want to remove a breadcrumb from the trail,
  # then you can selectively ignore breadcrumbs while building a notice.
  #
  # @return [Array] Active breadcrumbs
  def trail; end

  private

  # Since the collector is shared with the worker thread, there is a chance
  # it can be cleared before we have prepared the request. We provide the
  # ability to duplicate a collector which should also duplicate the buffer
  # instance, as that holds the breadcrumbs.
  #
  # @api private
  def initialize_dup(source); end
end

# This module is designed to be prepended into the
# ActiveSupport::LogSubscriber for the sole purpose of silencing breadcrumb
# log events. Since we already have specific breadcrumb events for each
# class that provides LogSubscriber events, we want to filter out those
# logs as they just become noise.
#
# @api private
module Honeybadger::Breadcrumbs::LogSubscriberInjector
  def debug(*args, &block); end
  def error(*args, &block); end
  def fatal(*args, &block); end
  def info(*args, &block); end
  def unknown(*args, &block); end
  def warn(*args, &block); end
end

# @api private
module Honeybadger::Breadcrumbs::LogWrapper
  # @api private
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end

  private

  # @api private
  # @return [Boolean]
  def should_ignore_log?(message, progname); end
end

class Honeybadger::Breadcrumbs::RingBuffer
  include ::Enumerable

  # @return [RingBuffer] a new instance of RingBuffer
  def initialize(buffer_size = T.unsafe(nil)); end

  def add!(item); end

  # Returns the value of attribute buffer.
  def buffer; end

  def clear!; end
  def drop; end
  def each(&blk); end
  def previous; end
  def to_a; end
end

# The Config class is used to manage Honeybadger's initialization and
# configuration.
#
# @api private
class Honeybadger::Config
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @api private
  # @return [Config] a new instance of Config
  def initialize(opts = T.unsafe(nil)); end

  # @api private
  def [](key); end

  # @api private
  def []=(key, value); end

  # @api private
  def backend; end

  # @api private
  def backend=(backend); end

  # @api private
  def backtrace_filter(&block); end

  # @api private
  def before_notify_hooks; end

  # @api private
  def ca_bundle_path; end

  # @api private
  # @yield [new_ruby]
  def configure; end

  # @api private
  def connection_port; end

  # @api private
  def connection_protocol; end

  # @api private
  # @return [Boolean]
  def debug?; end

  # @api private
  def detected_framework; end

  # @api private
  # @return [Boolean]
  def dev?; end

  # @api private
  def env; end

  # @api private
  def env=(_arg0); end

  # @api private
  def exception_filter(&block); end

  # @api private
  def exception_fingerprint(&block); end

  # @api private
  def excluded_request_keys; end

  # @api private
  def framework; end

  # @api private
  def framework=(_arg0); end

  # @api private
  def framework_name; end

  # @api private
  def get(key); end

  # @api private
  def ignored_classes; end

  # Called by framework (see lib/honeybadger/init/) at the point of
  # initialization. This is not required for the notifier to work (i.e. with
  # `require 'honeybadger/ruby'`).
  #
  # @api private
  def init!(opts = T.unsafe(nil), env = T.unsafe(nil)); end

  # @api private
  def load!(framework: T.unsafe(nil), env: T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def load_plugin?(name); end

  # @api private
  def local_cert_path; end

  # @api private
  # @return [Boolean]
  def log_debug?; end

  # @api private
  def log_level(key = T.unsafe(nil)); end

  # @api private
  def logger; end

  # @api private
  def max_queue_size; end

  # @api private
  def params_filters; end

  # @api private
  # @return [Boolean]
  def public?; end

  # @api private
  def root_regexp; end

  # @api private
  def ruby; end

  # @api private
  def ruby=(_arg0); end

  # @api private
  def set(key, value); end

  # @api private
  def to_h(defaults = T.unsafe(nil)); end

  # @api private
  def to_hash(defaults = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def warn_development?; end

  # @api private
  def yaml; end

  # @api private
  def yaml=(_arg0); end

  private

  # @api private
  def build_file_logger(path); end

  # @api private
  def build_logger; end

  # @api private
  def build_stdout_logger; end

  # @api private
  def config_path; end

  # @api private
  def config_paths; end

  # @api private
  def default_backend; end

  # @api private
  def detect_revision!; end

  # Takes an Array and a value and returns true if the value exists in the
  # array in String or Symbol form, otherwise false.
  #
  # @api private
  # @return [Boolean]
  def includes_token?(obj, value); end

  # @api private
  def init_backend!; end

  # @api private
  def init_logging!; end

  # @api private
  def load_config_from_disk; end

  # @api private
  def locate_absolute_path(path, root); end

  # @api private
  def log_path; end

  # @api private
  # @return [Boolean]
  def log_stdout?; end

  # @api private
  def undotify_keys(hash); end
end

class Honeybadger::Config::Boolean; end

# @api private
class Honeybadger::Config::ConfigError < ::StandardError; end

Honeybadger::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)
Honeybadger::Config::DEFAULT_PATHS = T.let(T.unsafe(nil), Array)
Honeybadger::Config::DEVELOPMENT_ENVIRONMENTS = T.let(T.unsafe(nil), Array)

# @api private
Honeybadger::Config::DOTTED_KEY = T.let(T.unsafe(nil), Regexp)

module Honeybadger::Config::Env
  class << self
    def cast_value(value, type = T.unsafe(nil)); end
    def new(env = T.unsafe(nil)); end
  end
end

Honeybadger::Config::Env::ARRAY_VALUES = T.let(T.unsafe(nil), Regexp)
Honeybadger::Config::Env::CONFIG_KEY = T.let(T.unsafe(nil), Regexp)
Honeybadger::Config::Env::CONFIG_MAPPING = T.let(T.unsafe(nil), Hash)
Honeybadger::Config::Env::IGNORED_TYPES = T.let(T.unsafe(nil), Set)
Honeybadger::Config::IGNORE_DEFAULT = T.let(T.unsafe(nil), Array)

# @api private
Honeybadger::Config::IVARS = T.let(T.unsafe(nil), Array)

# @api private
Honeybadger::Config::KEY_REPLACEMENT = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Config::Mash
  # @return [Mash] a new instance of Mash
  def initialize(config, prefix: T.unsafe(nil), hash: T.unsafe(nil)); end

  def to_h; end
  def to_hash; end

  private

  # Returns the value of attribute config.
  def config; end

  def get(key); end

  # @return [Boolean]
  def getter?(method_name); end

  # Returns the value of attribute hash.
  def hash; end

  def key(method_name); end

  # @return [Boolean]
  def mash?(method); end

  def method_missing(method_name, *args, &block); end

  # Returns the value of attribute prefix.
  def prefix; end

  # @return [Boolean]
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  # @return [Boolean]
  def setter?(method_name); end
end

Honeybadger::Config::Mash::KEYS = T.let(T.unsafe(nil), Array)

# @api private
Honeybadger::Config::NOT_BLANK = T.let(T.unsafe(nil), Regexp)

Honeybadger::Config::OPTIONS = T.let(T.unsafe(nil), Hash)

class Honeybadger::Config::Ruby < ::Honeybadger::Config::Mash
  def backend; end
  def backend=(backend); end
  def backtrace_filter(&block); end
  def before_notify(action = T.unsafe(nil), &block); end
  def exception_filter(&block); end
  def exception_fingerprint(&block); end
  def logger; end
  def logger=(logger); end

  private

  def validate_before_action(action); end
end

module Honeybadger::Config::Yaml
  class << self
    def dotify_keys(hash, key_prefix = T.unsafe(nil)); end
    def load_yaml(path); end
    def new(path, env = T.unsafe(nil)); end
  end
end

Honeybadger::Config::Yaml::DISALLOWED_KEYS = T.let(T.unsafe(nil), Array)

# @api private
class Honeybadger::ContextManager
  include ::Honeybadger::Conversions

  # @api private
  # @return [ContextManager] a new instance of ContextManager
  def initialize; end

  # @api private
  def clear!; end

  # @api private
  def get_context; end

  # @api private
  def get_rack_env; end

  # @api private
  def set_context(hash); end

  # @api private
  def set_rack_env(env); end

  private

  # @api private
  def _initialize; end

  # @api private
  def custom; end

  # @api private
  def custom=(_arg0); end

  # @api private
  def rack_env; end

  # @api private
  def rack_env=(_arg0); end

  class << self
    # @api private
    def current; end
  end
end

# @api private
module Honeybadger::Conversions
  private

  # Convert context into a Hash.
  #
  # @api private
  # @param object [Object] The context object.
  # @return [Hash] The hash context.
  def Context(object); end

  class << self
    # Convert context into a Hash.
    #
    # @api private
    # @param object [Object] The context object.
    # @return [Hash] The hash context.
    def Context(object); end
  end
end

# Substitution for gem root in backtrace lines.
#
# @api private
Honeybadger::GEM_ROOT = T.let(T.unsafe(nil), String)

module Honeybadger::Init; end
module Honeybadger::Init::Rails; end
class Honeybadger::Init::Rails::Railtie < ::Rails::Railtie; end

# @api private
module Honeybadger::Logging; end

# @api private
class Honeybadger::Logging::Base
  # @api private
  # @raise [NotImplementedError]
  def add(severity, msg); end

  def debug(msg); end
  def debug?; end
  def error(msg); end
  def error?; end
  def fatal(msg); end
  def fatal?; end
  def info(msg); end
  def info?; end

  # @api private
  def level; end

  def unknown(msg); end
  def unknown?; end
  def warn(msg); end
  def warn?; end
end

# @api private
class Honeybadger::Logging::BootLogger < ::Honeybadger::Logging::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @api private
  # @return [BootLogger] a new instance of BootLogger
  def initialize; end

  # @api private
  def add(severity, msg); end

  # @api private
  def flush(logger); end
end

# @api private
class Honeybadger::Logging::ConfigLogger < ::Honeybadger::Logging::StandardLogger
  # @api private
  # @return [ConfigLogger] a new instance of ConfigLogger
  def initialize(config, logger = T.unsafe(nil)); end

  # @api private
  def add(severity, msg); end

  # @api private
  # @return [Boolean]
  def debug?; end

  private

  # @api private
  def caller_location; end

  # @api private
  def supplement(msg, severity); end

  # @api private
  # @return [Boolean]
  def suppress_debug?; end

  # @api private
  # @return [Boolean]
  def suppress_tty?(severity); end
end

# @api private
Honeybadger::Logging::ConfigLogger::CALLER_LOCATION = T.let(T.unsafe(nil), Regexp)

# @api private
Honeybadger::Logging::ConfigLogger::DEBUG_SUPPLEMENT = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Logging::ConfigLogger::INFO_SUPPLEMENT = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Logging::ConfigLogger::LOCATE_CALLER_LOCATION = T.let(T.unsafe(nil), Regexp)

# @api private
class Honeybadger::Logging::FormattedLogger < ::Honeybadger::Logging::StandardLogger
  # @api private
  def add(severity, msg, progname = T.unsafe(nil)); end

  private

  # @api private
  def format_message(msg); end
end

# Logging helper methods. Requires a Honeybadger::Config @config instance
# variable to exist and/or #logger to be defined. Each method is
# defined/block captured in this module rather than delegating to the
# logger directly to avoid extra object allocation.
#
# @api private
module Honeybadger::Logging::Helper
  private

  # @api private
  def d(msg = T.unsafe(nil)); end

  # @api private
  def debug(msg = T.unsafe(nil)); end

  # @api private
  def error(msg = T.unsafe(nil)); end

  # @api private
  def info(msg = T.unsafe(nil)); end

  # @api private
  def logger; end

  # @api private
  def warn(msg = T.unsafe(nil)); end
end

# @api private
Honeybadger::Logging::LOGGER_PROG = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Logging::PREFIX = T.let(T.unsafe(nil), String)

# @api private
class Honeybadger::Logging::StandardLogger < ::Honeybadger::Logging::Base
  extend ::Forwardable

  # @api private
  # @raise [ArgumentError]
  # @return [StandardLogger] a new instance of StandardLogger
  def initialize(logger = T.unsafe(nil)); end

  # @api private
  def add(severity, msg, progname = T.unsafe(nil)); end

  def debug?(*args, **_arg1, &block); end
  def error?(*args, **_arg1, &block); end
  def info?(*args, **_arg1, &block); end
  def level(*args, **_arg1, &block); end
  def warn?(*args, **_arg1, &block); end
end

# @api private
Honeybadger::MAX_EXCEPTION_CAUSES = T.let(T.unsafe(nil), Integer)

# @api private
Honeybadger::NOTIFIER = T.let(T.unsafe(nil), Hash)

# A Regexp which matches non-blank characters.
#
# @api private
Honeybadger::NOT_BLANK = T.let(T.unsafe(nil), Regexp)

class Honeybadger::Notice
  include ::Honeybadger::Conversions
  extend ::Forwardable

  # @api private
  # @return [Notice] a new instance of Notice
  def initialize(config, opts = T.unsafe(nil)); end

  # The action (if any) that was called in this request.
  def action; end

  # The action (if any) that was called in this request.
  def action=(_arg0); end

  # The API key used to deliver this notice.
  def api_key; end

  # The API key used to deliver this notice.
  def api_key=(_arg0); end

  # Template used to create JSON payload.
  #
  # @api private
  # @return [Hash] JSON representation of notice.
  def as_json(*args); end

  # The backtrace from the given exception or hash.
  def backtrace; end

  # The backtrace from the given exception or hash.
  def backtrace=(_arg0); end

  # @return [Breadcrumbs::Collector] The collection of captured breadcrumbs
  def breadcrumbs; end

  # @return [Breadcrumbs::Collector] The collection of captured breadcrumbs
  def breadcrumbs=(_arg0); end

  # The exception cause if available.
  def cause; end

  def cause=(cause); end

  # @return [Cause] A list of exception causes (see {Cause})
  def causes; end

  # CGI variables such as HTTP_METHOD.
  def cgi_data; end

  # CGI variables such as HTTP_METHOD.
  def cgi_data=(_arg0); end

  # The component (if any) which was used in this request (usually the controller).
  def component; end

  # The component (if any) which was used in this request (usually the controller).
  def component=(_arg0); end

  # The context Hash.
  def context; end

  # The context Hash.
  def context=(_arg0); end

  # The component (if any) which was used in this request (usually the controller).
  def controller; end

  # The component (if any) which was used in this request (usually the controller).
  def controller=(_arg0); end

  # Custom details data
  def details; end

  # Custom details data
  def details=(_arg0); end

  # The name of the class of error (example: RuntimeError).
  def error_class; end

  # The name of the class of error (example: RuntimeError).
  def error_class=(_arg0); end

  # The message from the exception, or a general description of the error.
  def error_message; end

  # The message from the exception, or a general description of the error.
  def error_message=(_arg0); end

  # The exception that caused this notice, if any.
  def exception; end

  # Custom fingerprint for error, used to group similar errors together.
  def fingerprint; end

  # Custom fingerprint for error, used to group similar errors together.
  def fingerprint=(_arg0); end

  # Halts the notice and the before_notify callback chain.
  #
  # Returns nothing.
  def halt!; end

  # Determines if this notice will be discarded.
  #
  # @api private
  # @return [Boolean]
  def halted?; end

  # The unique ID of this notice which can be used to reference the error in
  # Honeybadger.
  def id; end

  # Determines if this notice should be ignored.
  #
  # @api private
  # @return [Boolean]
  def ignore?; end

  # Local variables are extracted from first frame of backtrace.
  def local_variables; end

  # Local variables are extracted from first frame of backtrace.
  def local_variables=(_arg0); end

  # A hash of parameters from the query string or post body.
  def parameters; end

  # A hash of parameters from the query string or post body.
  def params; end

  # A hash of parameters from the query string or post body.
  def params=(_arg0); end

  # A hash of session data from the request.
  def session; end

  # A hash of session data from the request.
  def session=(_arg0); end

  # Deprecated: Excerpt from source file.
  def source; end

  # Tags which will be applied to error.
  def tags; end

  def tags=(tags); end

  # Converts the notice to JSON.
  #
  # @return [Hash] The JSON representation of the notice.
  def to_json(*a); end

  # The URL at which the error occurred (if any).
  def url; end

  # The URL at which the error occurred (if any).
  def url=(_arg0); end

  private

  # Returns the value of attribute config.
  def config; end

  def construct_backtrace_filters(opts); end
  def construct_context_hash(opts, exception); end

  # Construct the request data.
  #
  # Returns Hash request data.
  def construct_request_hash; end

  def construct_tags(tags); end

  # Gets a property named "attribute" of an exception, either from
  # the #args hash or actual exception (in order of precidence).
  #
  # attribute - A Symbol existing as a key in #args and/or attribute on
  #             Exception.
  # default   - Default value if no other value is found (optional).
  # block     - An optional block which receives an Exception and returns the
  #             desired value.
  #
  # Returns attribute value from args or exception, otherwise default.
  def exception_attribute(attribute, default = T.unsafe(nil), &block); end

  # Fetch cause from exception.
  #
  # exception - Exception to fetch cause from.
  #
  # Returns the Exception cause.
  def exception_cause(exception); end

  # Get optional context from exception.
  #
  # Returns the Hash context.
  def exception_context(exception); end

  def fingerprint_from_opts(opts); end
  def fingerprint_hash; end

  # Gets a property named +attribute+ from an exception.
  #
  # If a block is given, it will be used when getting the property from an
  # exception. The block should accept and exception and return the value for
  # the property.
  #
  # If no block is given, a method with the same name as +attribute+ will be
  # invoked for the value.
  def from_exception(attribute); end

  # @return [Boolean]
  def ignore_by_callbacks?; end

  # Determines if error class should be ignored.
  #
  # ignored_class_name - The name of the ignored class. May be a
  # string or regexp (optional).
  #
  # Returns true or false.
  #
  # @return [Boolean]
  def ignore_by_class?(ignored_class = T.unsafe(nil)); end

  # @return [Boolean]
  def ignore_by_origin?; end

  # Fetch local variables from first frame of backtrace.
  #
  # exception - The Exception containing the bindings stack.
  #
  # Returns a Hash of local variables.
  def local_variables_from_exception(exception, config); end

  # Returns the value of attribute now.
  def now; end

  # Returns the value of attribute opts.
  def opts; end

  def params_filters; end

  # Parse Backtrace from exception backtrace.
  #
  # backtrace - The Array backtrace from exception.
  #
  # Returns the Backtrace.
  def parse_backtrace(backtrace); end

  # Returns the value of attribute pid.
  def pid; end

  # Convert list of causes into payload format.
  #
  # causes - Array of Cause instances.
  #
  # Returns the Array of causes in Hash payload format.
  def prepare_causes(causes); end

  # Returns the value of attribute rack_env.
  def rack_env; end

  def rails_params_filters; end
  def request_hash; end

  # Returns the value of attribute request_sanitizer.
  def request_sanitizer; end

  def s(data); end

  # Sanitize metadata to keep it at a single level and remove any filtered
  # parameters
  def sanitized_breadcrumbs; end

  # Should local variables be sent?
  #
  # Returns true to send local_variables.
  #
  # @return [Boolean]
  def send_local_variables?(config); end

  # Returns the value of attribute stats.
  def stats; end

  # Create a list of causes.
  #
  # cause - The first cause to unwrap.
  #
  # Returns the Array of Cause instances.
  def unwrap_causes(cause); end

  # Unwrap the exception so that original exception is ignored or
  # reported.
  #
  # exception - The exception which was rescued.
  #
  # Returns the Exception to report.
  def unwrap_exception(exception); end
end

# A list of backtrace filters to run all the time.
#
# @api private
Honeybadger::Notice::BACKTRACE_FILTERS = T.let(T.unsafe(nil), Array)

# @api private
class Honeybadger::Notice::Cause
  # @api private
  # @return [Cause] a new instance of Cause
  def initialize(cause); end

  # @api private
  def backtrace; end

  # @api private
  def backtrace=(_arg0); end

  # @api private
  def error_class; end

  # @api private
  def error_class=(_arg0); end

  # @api private
  def error_message; end

  # @api private
  def error_message=(_arg0); end
end

# Cache gem path substitutions for backtrace lines.
#
# @api private
Honeybadger::Notice::GEM_ROOT_CACHE = T.let(T.unsafe(nil), Hash)

# Cache project path substitutions for backtrace lines.
#
# @api private
Honeybadger::Notice::PROJECT_ROOT_CACHE = T.let(T.unsafe(nil), Hash)

# The Regexp used to strip invalid characters from individual tags.
#
# @api private
Honeybadger::Notice::TAG_SANITIZER = T.let(T.unsafe(nil), Regexp)

# The String character used to split tag strings.
#
# @api private
Honeybadger::Notice::TAG_SEPERATOR = T.let(T.unsafe(nil), Regexp)

# Substitution for project root in backtrace lines.
#
# @api private
Honeybadger::PROJECT_ROOT = T.let(T.unsafe(nil), String)

# +Honeybadger::Plugin+ defines the API for registering plugins with
# Honeybadger. Each plugin has requirements which must be satisfied before
# executing the plugin's execution block(s). This allows us to detect
# optional dependencies and load the plugin for each dependency only if it's
# present in the application.
#
# See the plugins/ directory for examples of official plugins. If you're
# interested in developing a plugin for Honeybadger, see the Integration
# Guide: https://docs.honeybadger.io/ruby/gem-reference/integration.html
#
# @example
#
#   require 'honeybadger/plugin'
#   require 'honeybadger/ruby'
#
#   module Honeybadger
#   module Plugins
#   # Register your plugin with an optional name. If the name (such as
#   # "my_framework") is not provided, Honeybadger will try to infer the name
#   # from the current file.
#   Plugin.register 'my_framework' do
#   requirement do
#   # Check to see if the thing you're integrating with is loaded. Return true
#   # if it is, or false if it isn't. An exception in this block is equivalent
#   # to returning false. Multiple requirement blocks are supported.
#   defined?(MyFramework)
#   end
#
#   execution do
#   # Write your integration. This code will be executed only if all requirement
#   # blocks return true. An exception in this block will disable the plugin.
#   # Multiple execution blocks are supported.
#   MyFramework.on_exception do |exception|
#   Honeybadger.notify(exception)
#   end
#   end
#   end
#   end
#   end
class Honeybadger::Plugin
  # @api private
  # @return [Plugin] a new instance of Plugin
  def initialize(name); end

  # Define an execution block. Execution blocks will be executed if all
  # requirement blocks return +true+.
  #
  # @example
  #
  #   Honeybadger::Plugin.register 'my_framework' do
  #   requirement { defined?(MyFramework) }
  #
  #   execution do
  #   MyFramework.on_exception {|err| Honeybadger.notify(err) }
  #   end
  #
  #   execution do
  #   # Honeybadger's configuration object is available inside
  #   # execution blocks. It should generally not be used outside of
  #   # internal plugins. See +Config+.
  #   MyFramework.use_middleware(MyMiddleware) if config[:'my_framework.use_middleware']
  #   end
  #   end
  # @return nil
  def execution(&block); end

  # @api private
  def executions; end

  # @api private
  def load!(config); end

  # @api private
  # @return [Boolean]
  def loaded?; end

  # @api private
  def name; end

  # @api private
  # @return [Boolean]
  def ok?(config); end

  # Define a requirement. All requirement blocks must return +true+ for the
  # plugin to be executed.
  #
  # @example
  #
  #   Honeybadger::Plugin.register 'my_framework' do
  #   requirement { defined?(MyFramework) }
  #
  #   # Honeybadger's configuration object is available inside
  #   # requirement blocks. It should generally not be used outside of
  #   # internal plugins. See +Config+.
  #   requirement { config[:'my_framework.enabled'] }
  #
  #   execution { }
  #   end
  # @return nil
  def requirement(&block); end

  # @api private
  def requirements; end

  # Used for testing only; don't normally call this. :)
  #
  # @private
  def reset!; end

  class << self
    # @api private
    def instances; end

    # @api private
    def load!(config); end

    # @api private
    def name_from_caller(caller); end

    # Register a new plugin with Honeybadger. See {#requirement} and {#execution}.
    #
    # @example
    #
    #   Honeybadger::Plugin.register 'my_framework' do
    #   requirement { }
    #   execution { }
    #   end
    # @param name [String, Symbol] The optional name of the plugin. Should use
    #   +snake_case+. The name is inferred from the current file name if omitted.
    # @return nil
    def register(name = T.unsafe(nil), &block); end
  end
end

# @api private
Honeybadger::Plugin::CALLER_FILE = T.let(T.unsafe(nil), Regexp)

# @api private
class Honeybadger::Plugin::Execution
  extend ::Forwardable

  # @api private
  # @return [Execution] a new instance of Execution
  def initialize(config, &block); end

  # @api private
  def call; end

  def logger(*args, **_arg1, &block); end

  private

  # @api private
  def block; end

  # @api private
  def config; end
end

# @api private
module Honeybadger::Plugins; end

# @api private
module Honeybadger::Plugins::Faktory; end

# @api private
class Honeybadger::Plugins::Faktory::Middleware
  # @api private
  def call(worker, job); end
end

# @api private
module Honeybadger::Plugins::LambdaExtension
  # Wrap Lambda handlers so exceptions can be automatically captured
  #
  # Usage:
  #
  # # Automatically included in the top-level main object
  # hb_wrap_handler :my_handler_1, :my_handler_2
  #
  # def my_handler_1(event:, context:)
  # end
  #
  # class MyLambdaApp
  #   extend ::Honeybadger::Plugins::LambdaExtension
  #
  #   hb_wrap_handler :my_handler_1, :my_handler_2
  #
  #   def self.my_handler_1(event:, context:)
  #   end
  # end
  #
  # @api private
  def hb_wrap_handler(*handler_names); end
end

# @api private
module Honeybadger::Plugins::LocalVariables; end

# @api private
module Honeybadger::Plugins::LocalVariables::ExceptionExtension
  # @api private
  def __honeybadger_bindings_stack; end

  # @api private
  def set_backtrace_with_honeybadger(*args, &block); end

  class << self
    # @api private
    # @private
    def included(base); end
  end
end

# @api private
module Honeybadger::Plugins::Passenger; end

# @api private
module Honeybadger::Plugins::Rails; end

# @api private
module Honeybadger::Plugins::Rails::ExceptionsCatcher
  # Adds additional Honeybadger info to Request env when an
  # exception is rendered in Rails' middleware.
  #
  # @api private
  # @param arg [Hash, ActionDispatch::Request] The Rack env +Hash+ in
  #   Rails 3.0-4.2. After Rails 5 +arg+ is an +ActionDispatch::Request+.
  # @param exception [Exception] The error which was rescued.
  # @return The super value of the middleware's +#render_exception()+
  #   method.
  def render_exception(arg, exception); end
end

# @api private
class Honeybadger::Plugins::RailsBreadcrumbs
  class << self
    # Used internally for sending out Rails Instrumentation breadcrumbs.
    #
    # @api private
    # @option notification_config
    # @option notification_config
    # @option notification_config
    # @option notification_config
    # @option notification_config
    # @param name [String] The ActiveSupport instrumentation key
    # @param duration [Number] The time spent in the instrumentation event
    # @param notification_config [Hash] The instrumentation event configuration
    # @param data [Hash] Custom metadata from the instrumentation event
    def send_breadcrumb_notification(name, duration, notification_config, data = T.unsafe(nil)); end

    # @api private
    def subscribe_to_notification(name, notification_config); end
  end
end

# @api private
module Honeybadger::Plugins::Resque; end

# @api private
module Honeybadger::Plugins::Resque::Extension
  # @api private
  def after_perform_with_honeybadger(*args); end

  # Executed before +on_failure+ hook; the flush is necessary so that
  # errors reported within jobs get sent before the worker dies.
  #
  # @api private
  def around_perform_with_honeybadger(*args); end

  # Error notifications must be synchronous as the +on_failure+ hook is
  # executed after +around_perform+.
  #
  # @api private
  def on_failure_with_honeybadger(e, *args); end

  # @api private
  # @return [Boolean]
  def send_exception_to_honeybadger?(e, args); end
end

# @api private
module Honeybadger::Plugins::Resque::Installer
  # @api private
  def payload_class_with_honeybadger; end

  class << self
    # @api private
    # @private
    def included(base); end
  end
end

# @api private
module Honeybadger::Plugins::Shoryuken; end

# @api private
class Honeybadger::Plugins::Shoryuken::Middleware
  # @api private
  def call(_worker, _queue, sqs_msg, body); end

  private

  # @api private
  def attempt_threshold; end

  # @api private
  def notification_params(body); end

  # @api private
  def receive_count(sqs_msg); end
end

# @api private
module Honeybadger::Plugins::Sidekiq; end

# @api private
class Honeybadger::Plugins::Sidekiq::Middleware
  # @api private
  def call(_worker, _msg, _queue); end
end

# @api private
module Honeybadger::Plugins::Thor
  # @api private
  def invoke_command_with_honeybadger(*args); end

  class << self
    # @api private
    # @private
    def included(base); end
  end
end

# Matches lines beginning with ./
#
# @api private
Honeybadger::RELATIVE_ROOT = T.let(T.unsafe(nil), Regexp)

module Honeybadger::Rack; end

# Middleware for Rack applications. Any errors raised by the upstream
# application will be delivered to Honeybadger and re-raised.
#
# @example
#   require 'honeybadger/rack/error_notifier'
#
#   app = Rack::Builder.app do
#   run lambda { |env| raise "Rack down" }
#   end
#
#   use Honeybadger::Rack::ErrorNotifier
#
#   run app
class Honeybadger::Rack::ErrorNotifier
  extend ::Forwardable

  # @return [ErrorNotifier] a new instance of ErrorNotifier
  def initialize(app, agent = T.unsafe(nil)); end

  def call(env); end
  def config(*args, **_arg1, &block); end
  def logger(*args, **_arg1, &block); end

  private

  def agent; end
  def framework_exception(env); end

  # @return [Boolean]
  def ignored_user_agent?(env); end

  def notify_honeybadger(exception, env); end
end

# Middleware for Rack applications. Adds a feedback form to the Rack
# response when an error has occurred.
class Honeybadger::Rack::UserFeedback
  extend ::Forwardable

  # @return [UserFeedback] a new instance of UserFeedback
  def initialize(app, agent = T.unsafe(nil)); end

  # @private
  # @todo Make this method and others actually private.
  def action; end

  def call(env); end
  def config(*args, **_arg1, &block); end

  # @private
  def custom_template_file; end

  # @private
  # @return [Boolean]
  def custom_template_file?; end

  def logger(*args, **_arg1, &block); end

  # @private
  def render_form(error_id, action = T.unsafe(nil)); end

  # @private
  def template_file; end

  private

  def agent; end
end

# Middleware for Rack applications. Adds an error ID to the Rack response
# when an error has occurred.
class Honeybadger::Rack::UserInformer
  extend ::Forwardable

  # @return [UserInformer] a new instance of UserInformer
  def initialize(app, agent = T.unsafe(nil)); end

  def call(env); end
  def config(*args, **_arg1, &block); end
  def logger(*args, **_arg1, &block); end
  def replacement(with); end

  private

  def agent; end
end

# Empty String (used for equality comparisons and assignment).
#
# @api private
Honeybadger::STRING_EMPTY = T.let(T.unsafe(nil), String)

# @api private
module Honeybadger::Util; end

# @api private
class Honeybadger::Util::HTTP
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @api private
  # @return [HTTP] a new instance of HTTP
  def initialize(config); end

  # @api private
  def get(endpoint); end

  # @api private
  def post(endpoint, payload, headers = T.unsafe(nil)); end

  private

  # @api private
  def compress(string, level = T.unsafe(nil)); end

  # @api private
  def config; end

  # @api private
  def http_connection; end

  # @api private
  def http_headers(headers = T.unsafe(nil)); end

  # @api private
  def setup_http_connection; end
end

# @api private
Honeybadger::Util::HTTP::ERRORS = T.let(T.unsafe(nil), Array)

# @api private
Honeybadger::Util::HTTP::HEADERS = T.let(T.unsafe(nil), Hash)

# @api private
class Honeybadger::Util::Lambda
  class << self
    # @api private
    # @return [Boolean]
    def lambda_execution?; end

    # @api private
    def normalized_data; end

    # @api private
    def trace_id; end
  end
end

# @api private
Honeybadger::Util::Lambda::AWS_ENV_MAP = T.let(T.unsafe(nil), Hash)

# Constructs a request hash from a Rack::Request matching the /v1/notices
# API specification.
#
# @api private
module Honeybadger::Util::RequestHash
  class << self
    # @api private
    def extract_cgi_data(request); end

    # @api private
    def extract_params(request); end

    # @api private
    def extract_session(request); end

    # @api private
    def extract_url(request); end

    # @api private
    def from_env(env); end
  end
end

# @api private
Honeybadger::Util::RequestHash::CGI_WHITELIST = T.let(T.unsafe(nil), Array)

# @api private
Honeybadger::Util::RequestHash::HTTP_HEADER_PREFIX = T.let(T.unsafe(nil), String)

# Constructs/sanitizes request data for notices
#
# @api private
module Honeybadger::Util::RequestPayload
  class << self
    # @api private
    def build(opts = T.unsafe(nil)); end
  end
end

# Default values to use for request data.
#
# @api private
Honeybadger::Util::RequestPayload::DEFAULTS = T.let(T.unsafe(nil), Hash)

# The cgi_data key where the raw Cookie header is stored.
#
# @api private
Honeybadger::Util::RequestPayload::HTTP_COOKIE_KEY = T.let(T.unsafe(nil), String)

# Allowed keys.
#
# @api private
Honeybadger::Util::RequestPayload::KEYS = T.let(T.unsafe(nil), Array)

# @api private
class Honeybadger::Util::Revision
  class << self
    # @api private
    def detect(root = T.unsafe(nil)); end

    private

    # @api private
    def from_capistrano(root); end

    # @api private
    def from_git; end

    # Requires (currently) alpha platform feature `heroku labs:enable
    # runtime-dyno-metadata`
    #
    # See https://devcenter.heroku.com/articles/dyno-metadata
    #
    # @api private
    def from_heroku; end
  end
end

# @api private
class Honeybadger::Util::SQL
  class << self
    # @api private
    def force_utf_8(string); end

    # @api private
    def obfuscate(sql, adapter); end
  end
end

# @api private
Honeybadger::Util::SQL::DQuotedData = T.let(T.unsafe(nil), Regexp)

# @api private
Honeybadger::Util::SQL::DoubleQuoters = T.let(T.unsafe(nil), Regexp)

# @api private
Honeybadger::Util::SQL::EmptyReplacement = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::SQL::EscapedQuotes = T.let(T.unsafe(nil), Regexp)

# @api private
Honeybadger::Util::SQL::Newline = T.let(T.unsafe(nil), Regexp)

# @api private
Honeybadger::Util::SQL::NumericData = T.let(T.unsafe(nil), Regexp)

# @api private
Honeybadger::Util::SQL::Replacement = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::SQL::SQuotedData = T.let(T.unsafe(nil), Regexp)

# Sanitizer sanitizes data for sending to Honeybadger's API. The filters
# are based on Rails' HTTP parameter filter.
#
# @api private
class Honeybadger::Util::Sanitizer
  # @api private
  # @return [Sanitizer] a new instance of Sanitizer
  def initialize(max_depth: T.unsafe(nil), filters: T.unsafe(nil)); end

  # @api private
  def filter_cookies(raw_cookies); end

  # @api private
  def filter_url(url); end

  # @api private
  def sanitize(data, depth = T.unsafe(nil), stack = T.unsafe(nil), parents = T.unsafe(nil)); end

  private

  # @api private
  # @return [Boolean]
  def basic_object?(object); end

  # @api private
  def blocks; end

  # @api private
  # @return [Boolean]
  def can_dup?(obj); end

  # @api private
  def deep_regexps; end

  # @api private
  # @return [Boolean]
  def filter_key?(key, parents = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def filters?; end

  # @api private
  # @return [Boolean]
  def inspected?(string); end

  # @api private
  def max_depth; end

  # @api private
  # @return [Boolean]
  def recursive?(data); end

  # @api private
  def regexps; end

  # @api private
  def sanitize_string(string); end

  # @api private
  def valid_encoding(string); end

  # @api private
  # @return [Boolean]
  def valid_encoding?(string); end

  class << self
    # @api private
    def sanitize(data); end
  end
end

# @api private
Honeybadger::Util::Sanitizer::BASIC_OBJECT = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::Sanitizer::COOKIE_PAIRS = T.let(T.unsafe(nil), Regexp)

# @api private
Honeybadger::Util::Sanitizer::COOKIE_PAIR_SEP = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::Sanitizer::COOKIE_SEP = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::Sanitizer::DEPTH = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::Sanitizer::ENCODE_OPTS = T.let(T.unsafe(nil), Hash)

# @api private
Honeybadger::Util::Sanitizer::FILTERED = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::Sanitizer::IMMUTABLE = T.let(T.unsafe(nil), Array)

# @api private
Honeybadger::Util::Sanitizer::MAX_STRING_SIZE = T.let(T.unsafe(nil), Integer)

# @api private
Honeybadger::Util::Sanitizer::RAISED = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::Sanitizer::RECURSION = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::Sanitizer::TRUNCATED = T.let(T.unsafe(nil), String)

# @api private
Honeybadger::Util::Sanitizer::VALID_ENCODINGS = T.let(T.unsafe(nil), Array)

# @api private
class Honeybadger::Util::Stats
  class << self
    # @api private
    def all; end

    # From https://github.com/bloopletech/webstats/blob/master/server/data_providers/cpu_info.rb
    #
    # @api private
    def load; end

    # From https://github.com/bloopletech/webstats/blob/master/server/data_providers/mem_info.rb
    #
    # @api private
    def memory; end

    private

    # @api private
    def run; end

    # @api private
    def run_loadavg; end

    # @api private
    def run_meminfo; end
  end
end

# The current String Honeybadger version.
Honeybadger::VERSION = T.let(T.unsafe(nil), String)

# A concurrent queue to notify the backend.
#
# @api private
class Honeybadger::Worker
  include ::Honeybadger::Logging::Helper
  extend ::Forwardable

  # @api private
  # @return [Worker] a new instance of Worker
  def initialize(config); end

  def backend(*args, **_arg1, &block); end

  # Blocks until queue is processed up to this point in time.
  #
  # @api private
  def flush; end

  # @api private
  def push(msg); end

  # @api private
  def send_now(msg); end

  # @api private
  def shutdown(force = T.unsafe(nil)); end

  # @api private
  def start; end

  private

  # @api private
  def calc_throttle_interval; end

  # @api private
  # @return [Boolean]
  def can_start?; end

  # @api private
  def config; end

  # @api private
  def dec_throttle; end

  # @api private
  def handle_response(msg, response); end

  # @api private
  def inc_throttle; end

  # @api private
  def kill!; end

  # @api private
  def marker; end

  # @api private
  def mutex; end

  # @api private
  def notify_backend(payload); end

  # @api private
  def pid; end

  # @api private
  def queue; end

  # Release the marker. Important to perform during cleanup when shutting
  # down, otherwise it could end up waiting indefinitely.
  #
  # @api private
  def release_marker; end

  # @api private
  def run; end

  # @api private
  # @return [Boolean]
  def shutdown?; end

  # @api private
  def signal_marker(marker); end

  # @api private
  def start_at; end

  # @api private
  def suspend(interval); end

  # @api private
  # @return [Boolean]
  def suspended?; end

  # @api private
  def thread; end

  # @api private
  def throttle; end

  # @api private
  def throttle_interval; end

  # @api private
  # @return [Boolean]
  def throttled?; end

  # @api private
  def work(msg); end
end

# The base number for the exponential backoff formula when calculating the
# throttle interval. `1.05 ** throttle` will reach an interval of 2 minutes
# after around 100 429 responses from the server.
#
# @api private
Honeybadger::Worker::BASE_THROTTLE = T.let(T.unsafe(nil), Float)

# Used to signal the worker to shutdown.
#
# @api private
Honeybadger::Worker::SHUTDOWN = T.let(T.unsafe(nil), Symbol)

# Sub-class thread so we have a named thread (useful for debugging in Thread.list).
#
# @api private
class Honeybadger::Worker::Thread < ::Thread; end
