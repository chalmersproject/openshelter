# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rgeo` gem.
# Please instead update this file by running `bin/tapioca gem rgeo`.

# -----------------------------------------------------------------------------
#
# Well-known text generator for RGeo
#
# -----------------------------------------------------------------------------
module RGeo; end

module RGeo::Cartesian
  class << self
    # Creates and returns a cartesian factory of the preferred
    # Cartesian implementation.
    #
    # The actual implementation returned depends on which ruby
    # interpreter is running and what libraries are available.
    # RGeo will try to provide a fully-functional and performant
    # implementation if possible. If not, the simple Cartesian
    # implementation will be returned.
    # In practice, this means it returns a Geos implementation if
    # available; otherwise it falls back to the simple implementation.
    #
    # The given options are passed to the factory's constructor.
    # What options are available depends on the particular
    # implementation. See RGeo::Geos.factory and
    # RGeo::Cartesian.simple_factory for details. Unsupported options
    # are ignored.
    def factory(opts = T.unsafe(nil)); end

    # Returns a Feature::FactoryGenerator that creates preferred
    # factories. The given options are used as the default options.
    #
    # A common case for this is to provide the <tt>:srs_database</tt>
    # as a default. Then, the factory generator need only be passed
    # an SRID and it will automatically fetch the appropriate Proj4
    # and CoordSys objects.
    def factory_generator(defaults = T.unsafe(nil)); end

    # Creates and returns a cartesian factory of the preferred
    # Cartesian implementation.
    #
    # The actual implementation returned depends on which ruby
    # interpreter is running and what libraries are available.
    # RGeo will try to provide a fully-functional and performant
    # implementation if possible. If not, the simple Cartesian
    # implementation will be returned.
    # In practice, this means it returns a Geos implementation if
    # available; otherwise it falls back to the simple implementation.
    #
    # The given options are passed to the factory's constructor.
    # What options are available depends on the particular
    # implementation. See RGeo::Geos.factory and
    # RGeo::Cartesian.simple_factory for details. Unsupported options
    # are ignored.
    def preferred_factory(opts = T.unsafe(nil)); end

    # Returns a Feature::FactoryGenerator that creates preferred
    # factories. The given options are used as the default options.
    #
    # A common case for this is to provide the <tt>:srs_database</tt>
    # as a default. Then, the factory generator need only be passed
    # an SRID and it will automatically fetch the appropriate Proj4
    # and CoordSys objects.
    def preferred_factory_generator(defaults = T.unsafe(nil)); end

    # Returns a factory for the simple Cartesian implementation. This
    # implementation provides all SFS 1.1 types, and also allows Z and
    # M coordinates. It does not depend on external libraries, and is
    # thus always available, but it does not implement many of the more
    # advanced geometric operations. These limitations are:
    #
    # * Relational operators such as Feature::Geometry#intersects? are
    #   not implemented for most types.
    # * Relational constructors such as Feature::Geometry#union are
    #   not implemented for most types.
    # * Buffer and convex hull calculations are not implemented for most
    #   types. Boundaries are available except for GeometryCollection.
    # * Length calculations are available, but areas are not. Distances
    #   are available only between points.
    # * Equality and simplicity evaluation are implemented for some but
    #   not all types.
    # * Assertions for polygons and multipolygons are not implemented.
    #
    # Unimplemented operations may raise Error::UnsupportedOperation
    # if invoked.
    #
    # Options include:
    #
    # [<tt>:srid</tt>]
    #   Set the SRID returned by geometries created by this factory.
    #   Default is 0.
    # [<tt>:proj4</tt>]
    #   The coordinate system in Proj4 format, either as a
    #   CoordSys::Proj4 object or as a string or hash representing the
    #   proj4 format. Optional.
    # [<tt>:coord_sys</tt>]
    #   The coordinate system in OGC form, either as a subclass of
    #   CoordSys::CS::CoordinateSystem, or as a string in WKT format.
    #   Optional.
    # [<tt>:srs_database</tt>]
    #   Optional. If provided, the value should be an implementation of
    #   CoordSys::SRSDatabase::Interface. If both this and an SRID are
    #   provided, they are used to look up the proj4 and coord_sys
    #   objects from a spatial reference system database.
    # [<tt>:has_z_coordinate</tt>]
    #   Support a Z coordinate. Default is false.
    # [<tt>:has_m_coordinate</tt>]
    #   Support an M coordinate. Default is false.
    # [<tt>:uses_lenient_assertions</tt>]
    #   If set to true, assertion checking is disabled. This includes
    #   simplicity checking on LinearRing, and validity checks on
    #   Polygon and MultiPolygon. This may speed up creation of certain
    #   objects, at the expense of not doing the proper checking for
    #   OGC compliance. Default is false.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKTParser.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. The value is a hash of
    #   configuration parameters for WKRep::WKBParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKBParser.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is <tt>{:convert_case => :upper}</tt>.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is the empty hash, indicating the default configuration
    #   for WKRep::WKBGenerator.
    def simple_factory(opts = T.unsafe(nil)); end

    # Returns a Feature::FactoryGenerator that creates simple factories.
    # The given options are used as the default options.
    #
    # A common case for this is to provide the <tt>:srs_database</tt>
    # as a default. Then, the factory generator need only be passed
    # an SRID and it will automatically fetch the appropriate Proj4
    # and CoordSys objects.
    def simple_factory_generator(defaults = T.unsafe(nil)); end
  end
end

# This provides includes some spatial analysis algorithms supporting
# Cartesian data.
module RGeo::Cartesian::Analysis
  class << self
    # Check orientation of a ring, returns `true` if it is counter-clockwise
    # and false otherwise.
    #
    # If the factory used is GEOS based, use the GEOS implementation to
    # check that. Otherwise, this methods falls back to `ring_direction`.
    #
    # == Note
    #
    # This method does not ensure a correct result for an invalid geometry.
    # You should make sure your ring is valid beforehand using `ring?`
    # if you are using a LineString, or directly `valid?` for a
    # `linear_ring?`.
    # This will be subject to changes in v3.
    #
    # @return [Boolean]
    def ccw?(ring); end

    # Check orientation of a ring, returns `true` if it is counter-clockwise
    # and false otherwise.
    #
    # If the factory used is GEOS based, use the GEOS implementation to
    # check that. Otherwise, this methods falls back to `ring_direction`.
    #
    # == Note
    #
    # This method does not ensure a correct result for an invalid geometry.
    # You should make sure your ring is valid beforehand using `ring?`
    # if you are using a LineString, or directly `valid?` for a
    # `linear_ring?`.
    # This will be subject to changes in v3.
    #
    # @return [Boolean]
    def counter_clockwise?(ring); end

    # Given a LineString, which must be a ring, determine whether the
    # ring proceeds clockwise or counterclockwise.
    # Returns 1 for counterclockwise, or -1 for clockwise.
    #
    # Returns 0 if the ring is empty.
    # The return value is undefined if the object is not a ring, or
    # is not in a Cartesian coordinate system.
    def ring_direction(ring); end
  end
end

# This is a bounding box for Cartesian data.
# The simple cartesian implementation uses this internally to compute
# envelopes. You may also use it directly to compute and represent
# bounding boxes.
#
# A bounding box is a set of ranges in each dimension: X, Y, as well
# as Z and M if supported. You can compute a bounding box for one or
# more geometry objects by creating a new bounding box object, and
# adding the geometries to it. You may then query it for the bounds,
# or use it to determine whether it encloses other geometries or
# bounding boxes.
class RGeo::Cartesian::BoundingBox
  # Create a new empty bounding box with the given factory.
  #
  # The factory defines the coordinate system for the bounding box,
  # and also defines whether it should track Z and M coordinates.
  # All geometries will be cast to this factory when added to this
  # bounding box, and any generated envelope geometry will have this
  # as its factory.
  #
  # Options include:
  #
  # [<tt>:ignore_z</tt>]
  #   If true, ignore z coordinates even if the factory supports them.
  #   Default is false.
  # [<tt>:ignore_m</tt>]
  #   If true, ignore m coordinates even if the factory supports them.
  #   Default is false.
  #
  # @return [BoundingBox] a new instance of BoundingBox
  def initialize(factory, opts = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(rhs); end

  # Adjusts the extents of this bounding box to encompass the given
  # object, which may be a geometry or another bounding box.
  # Returns self.
  def add(geometry); end

  def add_geometry(geometry); end

  # Returns the midpoint M, or nil if this bounding box is empty or has no M.
  def center_m; end

  # Returns the midpoint X, or nil if this bounding box is empty.
  def center_x; end

  # Returns the midpoint Y, or nil if this bounding box is empty.
  def center_y; end

  # Returns the midpoint Z, or nil if this bounding box is empty or has no Z.
  def center_z; end

  # Returns true if this bounding box contains the given object,
  # which may be a geometry or another bounding box.
  #
  # Supports these options:
  #
  # [<tt>:ignore_z</tt>]
  #   Ignore the Z coordinate when testing, even if both objects
  #   have Z. Default is false.
  # [<tt>:ignore_m</tt>]
  #   Ignore the M coordinate when testing, even if both objects
  #   have M. Default is false.
  #
  # @return [Boolean]
  def contains?(rhs, opts = T.unsafe(nil)); end

  # Returns true if this bounding box is degenerate. That is,
  # it is nonempty but has zero area because either or both
  # of the X or Y spans are 0.
  #
  # @return [Boolean]
  def degenerate?; end

  # Returns true if this bounding box is still empty.
  #
  # @return [Boolean]
  def empty?; end

  # @return [Boolean]
  def eql?(rhs); end

  # Returns the bounding box's factory.
  def factory; end

  # Returns true if this bounding box tracks M coordinates.
  def has_m; end

  # Returns true if this bounding box tracks Z coordinates.
  def has_z; end

  # Returns true if this bounding box is degenerate. That is,
  # it is nonempty but contains only a single point because both
  # the X and Y spans are 0. Infinitesimal boxes are also
  # always degenerate.
  #
  # @return [Boolean]
  def infinitesimal?; end

  # Returns the M span, 0 if this bounding box is empty, or nil if it has no M.
  def m_span; end

  # Returns the maximum M, or nil if this bounding box is empty.
  def max_m; end

  # Returns a point representing the maximum extent in all dimensions,
  # or nil if this bounding box is empty.
  def max_point; end

  # Returns the maximum X, or nil if this bounding box is empty.
  def max_x; end

  # Returns the maximum Y, or nil if this bounding box is empty.
  def max_y; end

  # Returns the maximum Z, or nil if this bounding box is empty.
  def max_z; end

  # Returns the minimum M, or nil if this bounding box is empty.
  def min_m; end

  # Returns a point representing the minimum extent in all dimensions,
  # or nil if this bounding box is empty.
  def min_point; end

  # Returns the minimum X, or nil if this bounding box is empty.
  def min_x; end

  # Returns the minimum Y, or nil if this bounding box is empty.
  def min_y; end

  # Returns the minimum Z, or nil if this bounding box is empty.
  def min_z; end

  # Returns this bounding box subdivided, as an array of bounding boxes.
  # If this bounding box is empty, returns the empty array.
  # If this bounding box is a point, returns a one-element array
  # containing the current point.
  # If the x or y span is 0, bisects the line.
  # Otherwise, generally returns a 4-1 subdivision in the X-Y plane.
  # Does not subdivide on Z or M.
  #
  # [<tt>:bisect_factor</tt>]
  #   An optional floating point value that should be greater than 1.0.
  #   If the ratio between the larger span and the smaller span is
  #   greater than this factor, the bounding box is divided only in
  #   half instead of fourths.
  def subdivide(opts = T.unsafe(nil)); end

  # Converts this bounding box to an envelope, which will be the
  # empty collection (if the bounding box is empty), a point (if the
  # bounding box is not empty but both spans are 0), a line (if only
  # one of the two spans is 0) or a polygon (if neither span is 0).
  def to_geometry; end

  # Returns the X span, or 0 if this bounding box is empty.
  def x_span; end

  # Returns the Y span, or 0 if this bounding box is empty.
  def y_span; end

  # Returns the Z span, 0 if this bounding box is empty, or nil if it has no Z.
  def z_span; end

  private

  def add_point(point); end

  class << self
    # Create a bounding box given a geometry to surround.
    # The bounding box will be given the factory of the geometry.
    # You may also provide the same options available to
    # BoundingBox.new.
    def create_from_geometry(geom, opts = T.unsafe(nil)); end

    # Create a bounding box given two corner points.
    # The bounding box will be given the factory of the first point.
    # You may also provide the same options available to
    # BoundingBox.new.
    def create_from_points(point1, point2, opts = T.unsafe(nil)); end
  end
end

# This class implements the factory for the simple cartesian
# implementation.
class RGeo::Cartesian::Factory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  # Create a new simple cartesian factory.
  #
  # See RGeo::Cartesian.simple_factory for a list of supported options.
  #
  # @return [Factory] a new instance of Factory
  def initialize(opts = T.unsafe(nil)); end

  # Equivalence test.
  #
  # @return [Boolean]
  def ==(rhs); end

  # See RGeo::Feature::Factory#collection
  def collection(elems); end

  # See RGeo::Feature::Factory#coord_sys
  def coord_sys; end

  # Psych support
  def encode_with(coder); end

  # Equivalence test.
  #
  # @return [Boolean]
  def eql?(rhs); end

  def generate_wkb(obj); end
  def generate_wkt(obj); end

  # Standard hash code
  def hash; end

  def init_with(coder); end

  # See RGeo::Feature::Factory#line
  def line(start, stop); end

  # See RGeo::Feature::Factory#line_string
  def line_string(points); end

  # See RGeo::Feature::Factory#linear_ring
  def linear_ring(points); end

  # Marshal support
  def marshal_dump; end

  def marshal_load(data); end
  def marshal_wkb_generator; end
  def marshal_wkb_parser; end

  # See RGeo::Feature::Factory#multi_line_string
  def multi_line_string(elems); end

  # See RGeo::Feature::Factory#multi_point
  def multi_point(elems); end

  # See RGeo::Feature::Factory#multi_polygon
  def multi_polygon(elems); end

  # See RGeo::Feature::Factory#parse_wkb
  def parse_wkb(str); end

  # See RGeo::Feature::Factory#parse_wkt
  def parse_wkt(str); end

  # See RGeo::Feature::Factory#point
  def point(x, y, *extra); end

  # See RGeo::Feature::Factory#polygon
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#proj4
  def proj4; end

  # See RGeo::Feature::Factory#property
  def property(name); end

  def psych_wkt_generator; end
  def psych_wkt_parser; end

  # Returns the SRID.
  def srid; end
end

class RGeo::Cartesian::GeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Cartesian::GeometryMethods
  def envelope; end
  def srid; end
end

class RGeo::Cartesian::LineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Cartesian::LineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Cartesian::LineStringMethods
  # @return [Boolean]
  def is_simple?; end

  def length; end
  def segments; end

  # @return [Boolean]
  def simple?; end
end

class RGeo::Cartesian::LinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::LineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Cartesian::MultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::MultiLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Cartesian::MultiLineStringMethods
  def length; end
end

class RGeo::Cartesian::MultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Cartesian::MultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Cartesian::PointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::Cartesian::PointMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Cartesian::PointMethods
  def buffer(distance); end
  def distance(rhs); end
end

class RGeo::Cartesian::PolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::Cartesian::GeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

# Represents a line segment in the plane.
class RGeo::Cartesian::Segment
  # @return [Segment] a new instance of Segment
  def initialize(start, stop); end

  # @return [Boolean]
  def ==(rhs); end

  # @return [Boolean]
  def contains_point?(p); end

  # @return [Boolean]
  def degenerate?; end

  # Returns the value of attribute dx.
  def dx; end

  # Returns the value of attribute dy.
  def dy; end

  # Returns the value of attribute e.
  def e; end

  # @return [Boolean]
  def eql?(rhs); end

  # @return [Boolean]
  def intersects_segment?(seg); end

  def length; end

  # Returns the value of attribute s.
  def s; end

  # Returns a negative value if the point is to the left,
  # a positive value if the point is to the right, or
  # 0 if the point is collinear to the segment.
  def side(p); end

  def to_s; end
  def tproj(p); end
end

# This module provides data structures and tools related to coordinate
# systems and coordinate transforms. It comprises the following parts:
#
# RGeo::CoordSys::Proj4 is a wrapper around the proj4 library, which
# defines a commonly-used syntax for specifying geographic and projected
# coordinate systems, and performs coordinate transformations.
#
# The RGeo::CoordSys::CS module contains an implementation of the CS
# (coordinate systems) package of the OGC Coordinate Transform spec.
# This includes classes for representing ellipsoids, datums, coordinate
# systems, and other related concepts, as well as a parser for the WKT
# format for specifying coordinate systems.
#
# The RGeo::CoordSys::SRSDatabase module contains tools for accessing
# spatial reference databases, from which you can look up coordinate
# system specifications. You can access the <tt>spatial_ref_sys</tt>
# table provided with OGC-compliant spatial databases such as PostGIS,
# read the databases provided with the proj4 library, or access URLs
# such as those provided by spatialreference.org.
module RGeo::CoordSys
  class << self
    def check!(key); end

    # The only valid key is :proj4
    #
    # @raise [Error::UnsupportedOperation]
    # @return [Boolean]
    def supported?(key); end
  end
end

# This module contains an implementation of the CS (coordinate
# systems) package of the OGC Coordinate Transform spec. It provides
# classes for representing ellipsoids, datums, coordinate systems,
# and other related concepts, as well as a parser for the WKT format
# for specifying coordinate systems.
#
# Generally, the easiest way to create coordinate system objects is
# to use RGeo::CoordSys::CS.create_from_wkt, which parses the WKT
# format. You can also use the create methods available for each
# object class.
#
# Most but not all of the spec is implemented here.
# Currently missing are:
#
# * XML format is not implemented. We're assuming that WKT is the
#   preferred format.
# * The PT and CT packages are not implemented.
# * FittedCoordinateSystem is not implemented.
# * The defaultEnvelope attribute of CS_CoordinateSystem is not
#   implemented.
module RGeo::CoordSys::CS
  class << self
    # Parsees OGC WKT format and returns the object created. Raises
    # Error::ParseError if a syntax error is encounterred.
    def create_from_wkt(str); end
  end
end

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go down. This is used for vertical
# coordinate systems.
RGeo::CoordSys::CS::AO_DOWN = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go East. This is rarely used.
RGeo::CoordSys::CS::AO_EAST = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go North. This is usually used for
# Grid Y coordinates and Latitude.
RGeo::CoordSys::CS::AO_NORTH = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Unknown or unspecified axis orientation. This can be used for
# local or fitted coordinate systems.
RGeo::CoordSys::CS::AO_OTHER = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go South. This is rarely used.
RGeo::CoordSys::CS::AO_SOUTH = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go up. This is used for vertical
# coordinate systems.
RGeo::CoordSys::CS::AO_UP = T.let(T.unsafe(nil), Integer)

# An axis orientation constant for AxisInfo.
# Increasing ordinates values go West. This is usually used for
# Grid X coordinates and Longitude.
RGeo::CoordSys::CS::AO_WEST = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# Definition of angular units.
class RGeo::CoordSys::CS::AngularUnit < ::RGeo::CoordSys::CS::Unit
  # Returns the number of radians per AngularUnit.
  # Also available as Unit#conversion_factor.
  def radians_per_unit; end

  class << self
    # Create an AngularUnit given a unit name and a conversion
    # factor in radians per unit. You may also provide the optional
    # parameters specified by the Info interface.
    def create(name, radians_per_unit, *optional); end
  end
end

# == OGC spec description
#
# Details of axis. This is used to label axes, and indicate the
# orientation.
class RGeo::CoordSys::CS::AxisInfo < ::RGeo::CoordSys::CS::Base
  # :startdoc:
  #
  # @return [AxisInfo] a new instance of AxisInfo
  def initialize(name, orientation); end

  # Human readable name for axis. Possible values are "X", "Y",
  # "Long", "Lat" or any other short string.
  def name; end

  # Gets enumerated value for orientation.
  def orientation; end

  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    # Creates an AxisInfo. you must pass the human readable name for
    # the axis (e.g. "X", "Y", "Long", "Lat", or other short string)
    # and either an integer orientation code or a string. Possible
    # orientation values are "<tt>OTHER</tt>", "<tt>NORTH</tt>",
    # "<tt>SOUTH</tt>", "<tt>EAST</tt>", "<tt>WEST</tt>",
    # "<tt>UP</tt>", and "<tt>DOWN</tt>", or the corresponding
    # integer values 0-5.
    def create(name, orientation); end
  end
end

# :stopdoc:
RGeo::CoordSys::CS::AxisInfo::NAMES_BY_VALUE = T.let(T.unsafe(nil), Array)

# This is a base class for all OGC coordinate system objects.
# This includes both interfaces and data types from the OGC
# Coordinate Transformation spec.
#
# This is a non-instantiable abstract class.
class RGeo::CoordSys::CS::Base
  # Tests for equality. Two objects are defined as equal if they
  # have the same type (class) and the same WKT representation.
  #
  # @return [Boolean]
  def ==(rhs); end

  # Psych support
  def encode_with(coder); end

  # Tests for equality. Two objects are defined as equal if they
  # have the same type (class) and the same WKT representation.
  #
  # @return [Boolean]
  def eql?(rhs); end

  # Standard hash code
  def hash; end

  def init_with(coder); end

  # Standard object inspection output
  def inspect; end

  # Marshal support
  def marshal_dump; end

  def marshal_load(data); end

  # Returns the default WKT representation.
  def to_s; end

  # Return the WKT representation.
  #
  # <tt>:standard_brackets</tt>
  #   If true, outputs parentheses rather than square
  #   brackets. Default is false.
  def to_wkt(standard_brackets = T.unsafe(nil)); end

  private

  def brackets(standard); end
end

# == OGC spec description
#
# An aggregate of two coordinate systems (CRS). One of these is
# usually a CRS based on a two dimensional coordinate system such
# as a geographic or a projected coordinate system with a horizontal
# datum. The other is a vertical CRS which is a one-dimensional
# coordinate system with a vertical datum.
class RGeo::CoordSys::CS::CompoundCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [CompoundCoordinateSystem] a new instance of CompoundCoordinateSystem
  def initialize(name, head, tail, *optional); end

  # Implements CoordinateSystem#get_axis
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  def get_units(index); end

  # Gets first sub-coordinate system.
  def head; end

  # Gets second sub-coordinate system.
  def tail; end

  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    # Create a CompoundCoordinateSystem given two sub-coordinate
    # systems. You may also provide the optional parameters
    # specified by the Info interface.
    def create(name, head, tail, *optional); end
  end
end

# == OGC spec description
#
# Base interface for all coordinate systems.
#
# A coordinate system is a mathematical space, where the elements
# of the space are called positions. Each position is described by
# a list of numbers. The length of the list corresponds to the
# dimension of the coordinate system. So in a 2D coordinate system
# each position is described by a list containing 2 numbers.
#
# However, in a coordinate system, not all lists of numbers
# correspond to a position -- some lists may be outside the domain
# of the coordinate system. For example, in a 2D Lat/Lon coordinate
# system, the list (91,91) does not correspond to a position.
#
# Some coordinate systems also have a mapping from the mathematical
# space into locations in the real world. So in a Lat/Lon coordinate
# system, the mathematical position (lat, long) corresponds to a
# location on the surface of the Earth. This mapping from the
# mathematical space into real-world locations is called a Datum.
#
# == Notes
#
# This is a non-instantiable abstract class. You must instantiate
# one of the subclasses GeocentricCoordinateSystem,
# GeographicCoordinateSystem, ProjectedCoordinateSystem,
# VerticalCoordinateSystem, LocalCoordinateSystem, or
# CompoundCoordinateSystem.
class RGeo::CoordSys::CS::CoordinateSystem < ::RGeo::CoordSys::CS::Info
  # @return [CoordinateSystem] a new instance of CoordinateSystem
  def initialize(name, dimension, *optional); end

  # Dimension of the coordinate system
  def dimension; end

  # Gets axis details for dimension within coordinate system. Each
  # dimension in the coordinate system has a corresponding axis.
  def get_axis(dimension); end

  # Gets units for dimension within coordinate system. Each
  # dimension in the coordinate system has corresponding units.
  def get_units(dimension); end
end

# A class implementing the CS_CoordinateSystemFactory interface.
# It provides methods for building up complex objects from simpler
# objects or values.
#
# Note that the methods of CS_CoordinateSystemFactory do not provide
# facilities for setting the authority. If you need to set authority
# values, use the create methods for the object classes themselves.
class RGeo::CoordSys::CS::CoordinateSystemFactory
  # Create a CompoundCoordinateSystem from a name, and two
  # constituent coordinate systems.
  def create_compound_coordinate_system(name, head, tail); end

  # Create an Ellipsoid from a name, semi-major axis, and semi-minor
  # axis. You can also provide a LinearUnit, but this is optional
  # and may be set to nil.
  def create_ellipsoid(name, semi_major_axis, semi_minor_axis, linear_unit); end

  # Create an Ellipsoid from a name, semi-major axis, and an inverse
  # flattening factor. You can also provide a LinearUnit, but this
  # is optional and may be set to nil.
  def create_flattened_sphere(name, semi_major_axis, inverse_flattening, linear_unit); end

  # Create any object given the OGC WKT format. Raises
  # Error::ParseError if a syntax error is encounterred.
  def create_from_wkt(str); end

  # Create a GeographicCoordinateSystem, given a name, an
  # AngularUnit, a HorizontalDatum, a PrimeMeridian, and two
  # AxisInfo objects. The AxisInfo objects are optional and may be
  # set to nil.
  def create_geographic_coordinate_system(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1); end

  # Create a HorizontalDatum given a name, a horizontal datum type
  # code, an Ellipsoid, and a WGS84ConversionInfo. The
  # WGS84ConversionInfo is optional and may be set to nil.
  def create_horizontal_datum(name, horizontal_datum_type, ellipsoid, to_wgs84); end

  # Create a LocalCoordinateSystem given a name, a LocalDatum, a
  # Unit, and an array of at least one AxisInfo.
  def create_local_coordinate_system(name, datum, unit, axes); end

  # Create a LocalDatum given a name and a local datum type code.
  def create_local_datum(_name, local_datum_type); end

  # Create a PrimeMeridian given a name, an AngularUnit, and a
  # longitude offset.
  def create_prime_meridian(_name, angular_unit, longitude); end

  # Create a ProjectedCoordinateSystem given a name, a
  # GeographicCoordinateSystem, and Projection, a LinearUnit, and
  # two AxisInfo objects. The AxisInfo objects are optional and may
  # be set to nil.
  def create_projected_coordinate_system(name, gcs, projection, linear_unit, axis0, axis1); end

  # Create a Projection given a name, a projection class, and an
  # array of ProjectionParameter.
  def create_projection(name, wkt_projection_class, parameters); end

  # Create a VerticalCoordinateSystem given a name, a VerticalDatum,
  # a VerticalUnit, and an AxisInfo. The AxisInfo is optional and
  # may be nil.
  def create_vertical_coordinate_system(name, vertical_datum, vertical_unit, axis); end

  # Create a VerticalDatum given a name ane a datum type code.
  def create_vertical_datum(name, vertical_datum_type); end
end

# == OGC spec description
#
# A set of quantities from which other quantities are calculated.
# For the OGC abstract model, it can be defined as a set of real
# points on the earth that have coordinates. EG. A datum can be
# thought of as a set of parameters defining completely the origin
# and orientation of a coordinate system with respect to the earth.
# A textual description and/or a set of parameters describing the
# relationship of a coordinate system to some predefined physical
# locations (such as center of mass) and physical directions (such
# as axis of spin). The definition of the datum may also include
# the temporal behavior (such as the rate of change of the
# orientation of the coordinate axes).
#
# == Notes
#
# This is a non-instantiable abstract class. You must instantiate
# one of the subclasses HorizontalDatum, VerticalDatum, or
# LocalDatum.
class RGeo::CoordSys::CS::Datum < ::RGeo::CoordSys::CS::Info
  # @return [Datum] a new instance of Datum
  def initialize(name, datum_type, *optional); end

  # Gets the type of the datum as an enumerated code.
  def datum_type; end

  private

  def wkt_content(_); end
end

# == OGC spec description
#
# An approximation of the Earth's surface as a squashed sphere.
class RGeo::CoordSys::CS::Ellipsoid < ::RGeo::CoordSys::CS::Info
  # @return [Ellipsoid] a new instance of Ellipsoid
  def initialize(name, semi_major_axis, semi_minor_axis, inverse_flattening, ivf_definitive, linear_unit, *optional); end

  # Returns the LinearUnit. The units of the semi-major and
  # semi-minor axis values.
  def axisunit; end

  # Returns the value of the inverse of the flattening constant. The
  # inverse flattening is related to the equatorial/polar radius by
  # the formula ivf=re/(re-rp). For perfect spheres, this formula
  # breaks down, and a special IVF value of zero is used.
  def inverse_flattening; end

  # Is the Inverse Flattening definitive for this ellipsoid? Some
  # ellipsoids use the IVF as the defining value, and calculate the
  # polar radius whenever asked. Other ellipsoids use the polar
  # radius to calculate the IVF whenever asked. This distinction can
  # be important to avoid floating-point rounding errors.
  def ivf_definitive; end

  # Gets the equatorial radius. The returned length is expressed in
  # this object's axis units.
  def semi_major_axis; end

  # Gets the polar radius. The returned length is expressed in this
  # object's axis units.
  def semi_minor_axis; end

  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    # Create an Ellipsoid given a name, semi-major and semi-minor
    # axes, the inverse flattening, a boolean indicating whether
    # the inverse flattening is definitive, and the LinearUnit
    # indicating the axis units. The LinearUnit is optional and
    # may be set to nil. You may also provide the optional parameters
    # specified by the Info interface.
    def create(name, semi_major_axis, semi_minor_axis, inverse_flattening, ivf_definitive, linear_unit, *optional); end

    # Create an Ellipsoid given a name, semi-major and semi-minor
    # axes, and the LinearUnit indicating the axis units. In the
    # resulting ellipsoid, the inverse flattening is not definitive.
    # The LinearUnit is optional and may be set to nil. You may also
    # provide the optional parameters specified by the Info interface.
    def create_ellipsoid(name, semi_major_axis, semi_minor_axis, linear_unit, *optional); end

    # Create an Ellipsoid given a name, semi-major axis, inverse
    # flattening, and the LinearUnit indicating the axis units. In
    # the resulting ellipsoid, the inverse flattening is definitive.
    # The LinearUnit is optional and may be set to nil. You may also
    # provide the optional parameters specified by the Info interface.
    def create_flattened_sphere(name, semi_major_axis, inverse_flattening, linear_unit, *optional); end
  end
end

# == OGC spec description
#
# A 3D coordinate system, with its origin at the centre of the
# Earth. The X axis points towards the prime meridian. The Y axis
# points East or West. The Z axis points North or South. By default
# the Z axis will point North, and the Y axis will point East (e.g.
# a right handed system), but you should check the axes for
# non-default values.
class RGeo::CoordSys::CS::GeocentricCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [GeocentricCoordinateSystem] a new instance of GeocentricCoordinateSystem
  def initialize(name, horizontal_datum, prime_meridian, linear_unit, axis0, axis1, axis2, *optional); end

  # Implements CoordinateSystem#get_axis
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  def get_units(index); end

  # Returns the HorizontalDatum. The horizontal datum is used to
  # determine where the centre of the Earth is considered to be.
  # All coordinate points will be measured from the centre of the
  # Earth, and not the surface.
  def horizontal_datum; end

  # Gets the units used along all the axes.
  def linear_unit; end

  # Returns the PrimeMeridian.
  def prime_meridian; end

  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    # Create a GeocentricCoordinateSystem given a name, a
    # HorizontalDatum, a PrimeMeridian, a LinearUnit, and three
    # AxisInfo objects. The AxisInfo are optional and may be nil.
    # You may also provide the optional parameters specified by the
    # Info interface.
    def create(name, horizontal_datum, prime_meridian, linear_unit, axis0, axis1, axis2, *optional); end
  end
end

# == OGC spec description
#
# A coordinate system based on latitude and longitude. Some
# geographic coordinate systems are Lat/Lon, and some are Lon/Lat.
# You can find out which this is by examining the axes. You should
# also check the angular units, since not all geographic coordinate
# systems use degrees.
class RGeo::CoordSys::CS::GeographicCoordinateSystem < ::RGeo::CoordSys::CS::HorizontalCoordinateSystem
  # @return [GeographicCoordinateSystem] a new instance of GeographicCoordinateSystem
  def initialize(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1, *optional); end

  # Returns the AngularUnit. The angular unit must be the same as
  # the CS_CoordinateSystem units.
  def angular_unit; end

  # Implements CoordinateSystem#get_axis
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  def get_units(index); end

  # Gets details on a conversion to WGS84. Some geographic
  # coordinate systems provide several transformations into WGS84,
  # which are designed to provide good accuracy in different areas
  # of interest. The first conversion (with index=0) should provide
  # acceptable accuracy over the largest possible area of interest.
  def get_wgs84_conversion_info(index); end

  # Gets the number of available conversions to WGS84 coordinates.
  def num_conversion_to_wgs84; end

  # Returns the PrimeMeridian.
  def prime_meridian; end

  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    # Create a GeographicCoordinateSystem, given a name, an
    # AngularUnit, a HorizontalDatum, a PrimeMeridian, and two
    # AxisInfo objects. The AxisInfo objects are optional and may
    # be set to nil. You may also provide the optional parameters
    # specified by the Info interface.
    def create(name, angular_unit, horizontal_datum, prime_meridian, axis0, axis1, *optional); end
  end
end

# A datum type constant for HorizontalDatum.
# These datums, such as ED50, NAD27 and NAD83, have been designed
# to support horizontal positions on the ellipsoid as opposed to
# positions in 3-D space. These datums were designed mainly to
# support a horizontal component of a position in a domain of
# limited extent, such as a country, a region or a continent.
RGeo::CoordSys::CS::HD_CLASSIC = T.let(T.unsafe(nil), Integer)

# A datum type constant for HorizontalDatum.
# A geocentric datum is a "satellite age" modern geodetic datum
# mainly of global extent, such as WGS84 (used in GPS), PZ90 (used
# in GLONASS) and ITRF. These datums were designed to support both
# a horizontal component of position and a vertical component of
# position (through ellipsoidal heights). The regional realizations
# of ITRF, such as ETRF, are also included in this category.
RGeo::CoordSys::CS::HD_GEOCENTRIC = T.let(T.unsafe(nil), Integer)

# A datum type constant for HorizontalDatum.
# Highest possible value for horizontal datum types.
RGeo::CoordSys::CS::HD_MAX = T.let(T.unsafe(nil), Integer)

# A datum type constant for HorizontalDatum.
# Lowest possible value for horizontal datum types.
RGeo::CoordSys::CS::HD_MIN = T.let(T.unsafe(nil), Integer)

# A datum type constant for HorizontalDatum.
# Unspecified horizontal datum type. Horizontal datums with this
# type should never supply a conversion to WGS84 using Bursa Wolf
# parameters.
RGeo::CoordSys::CS::HD_OTHER = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# A 2D coordinate system suitable for positions on the Earth's surface.
#
# == Notes
#
# This is a non-instantiable abstract class. You must instantiate
# one of the subclasses GeographicCoordinateSystem or
# ProjectedCoordinateSystem.
class RGeo::CoordSys::CS::HorizontalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [HorizontalCoordinateSystem] a new instance of HorizontalCoordinateSystem
  def initialize(name, horizontal_datum, *optional); end

  # Returns the HorizontalDatum.
  def horizontal_datum; end
end

# == OGC spec description
#
# Procedure used to measure positions on the surface of the Earth.
class RGeo::CoordSys::CS::HorizontalDatum < ::RGeo::CoordSys::CS::Datum
  # @return [HorizontalDatum] a new instance of HorizontalDatum
  def initialize(name, datum_type, ellipsoid, wgs84_parameters, *optional); end

  # Returns the Ellipsoid.
  def ellipsoid; end

  # Gets preferred parameters for a Bursa Wolf transformation into
  # WGS84. The 7 returned values correspond to (dx,dy,dz) in meters,
  # (ex,ey,ez) in arc-seconds, and scaling in parts-per-million.
  def wgs84_parameters; end

  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    # Create a HorizontalDatum given a name, datum type code,
    # Ellipsoid, and WGS84ConversionInfo. The WGS84ConversionInfo
    # is optional and may be set to nil. You may also provide the
    # optional parameters specified by the Info interface.
    def create(name, datum_type, ellipsoid, wgs84_parameters, *optional); end
  end
end

# == OGC spec description
#
# A base interface for metadata applicable to coordinate system
# objects.
#
# The metadata items "Abbreviation", "Alias", "Authority",
# "AuthorityCode", "Name" and "Remarks" were specified in the Simple
# Features interfaces, so they have been kept here.
#
# This specification does not dictate what the contents of these
# items should be. However, the following guidelines are suggested:
#
# When CS_CoordinateSystemAuthorityFactory is used to create an
# object, the "Authority" and "AuthorityCode" values should be set
# to the authority name of the factory object, and the authority
# code supplied by the client, respectively. The other values may or
# may not be set. (If the authority is EPSG, the implementer may
# consider using the corresponding metadata values in the EPSG
# tables.)
#
# When CS_CoordinateSystemFactory creates an object, the "Name"
# should be set to the value supplied by the client. All of the
# other metadata items should be left empty.
#
# == Notes
#
# This is a non-instantiable abstract class.
#
# Most subclasses will have a set of optional parameters in their
# "create" method to set the metadata fields. These parameters are,
# in order:
#
# * <b>authority</b>: authority name
# * <b>authority_code</b>: authority-specific identification code
# * <b>abbreviation</b>: an abbreviation
# * <b>alias</b>: an alias
# * <b>remarks</b>: provider-supplied remarks.
# * <b>extensions</b>: a hash of extension keys and values
class RGeo::CoordSys::CS::Info < ::RGeo::CoordSys::CS::Base
  # @return [Info] a new instance of Info
  def initialize(name, authority = T.unsafe(nil), authority_code = T.unsafe(nil), abbreviation = T.unsafe(nil), init_alias = T.unsafe(nil), remarks = T.unsafe(nil), extensions = T.unsafe(nil)); end

  # Gets the abbreviation.
  def abbreviation; end

  # Gets the alias.
  def alias; end

  # Gets the authority name.
  # An Authority is an organization that maintains definitions of
  # Authority Codes. For example the European Petroleum Survey Group
  # (EPSG) maintains a database of coordinate systems, and other
  # spatial referencing objects, where each object has a code number
  # ID. For example, the EPSG code for a WGS84 Lat/Lon coordinate
  # system is "4326".
  def authority; end

  # Gets the authority-specific identification code.
  # The AuthorityCode is a compact string defined by an Authority to
  # reference a particular spatial reference object. For example,
  # the European Survey Group (EPSG) authority uses 32 bit integers
  # to reference coordinate systems, so all their code strings will
  # consist of a few digits. The EPSG code for WGS84 Lat/Lon is
  # "4326".
  def authority_code; end

  # Gets the value of a keyed extension.
  # This is not part of the OGC spec, but it is supported because
  # some coordinate system databases (such as the spatial_ref_sys
  # table for PostGIS 2.0) include it.
  def extension(key); end

  # Gets the name.
  def name; end

  # Gets the provider-supplied remarks.
  def remarks; end
end

# A datum type constant for LocalDatum.
# Highest possible value for local datum types.
RGeo::CoordSys::CS::LD_MAX = T.let(T.unsafe(nil), Integer)

# A datum type constant for LocalDatum.
# Lowest possible value for local datum types.
RGeo::CoordSys::CS::LD_MIN = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# Definition of linear units.
class RGeo::CoordSys::CS::LinearUnit < ::RGeo::CoordSys::CS::Unit
  # Returns the number of meters per LinearUnit.
  # Also available as Unit#conversion_factor.
  def meters_per_unit; end

  class << self
    # Create a LinearUnit given a unit name and a conversion factor
    # in meters per unit. You may also provide the optional
    # parameters specified by the Info interface.
    def create(name, meters_per_unit, *optional); end
  end
end

# == OGC spec description
#
# A local coordinate system, with uncertain relationship to the
# world. In general, a local coordinate system cannot be related to
# other coordinate systems. However, if two objects supporting this
# interface have the same dimension, axes, units and datum then
# client code is permitted to assume that the two coordinate systems
# are identical. This allows several datasets from a common source
# (e.g. a CAD system) to be overlaid. In addition, some
# implementations of the Coordinate Transformation (CT) package may
# have a mechanism for correlating local datums. (E.g. from a
# database of transformations, which is created and maintained from
# real-world measurements.)
#
# == Notes
#
# RGeo's implementation does not provide the Coordinate
# Transformation (CT) package.
class RGeo::CoordSys::CS::LocalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [LocalCoordinateSystem] a new instance of LocalCoordinateSystem
  def initialize(name, local_datum, unit, axes, *optional); end

  # Implements CoordinateSystem#get_axis
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  def get_units(index); end

  # Gets the local datum.
  def local_datum; end

  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    # Create a LocalCoordinateSystem given a name, a LocalDatum, a
    # Unit, and an array of at least one AxisInfo. You may also
    # provide the optional parameters specified by the Info
    # interface.
    def create(name, local_datum, unit, axes, *optional); end
  end
end

# == OGC spec description
#
# Local datum. If two local datum objects have the same datum type
# and name, then they can be considered equal. This means that
# coordinates can be transformed between two different local
# coordinate systems, as long as they are based on the same local
# datum.
class RGeo::CoordSys::CS::LocalDatum < ::RGeo::CoordSys::CS::Datum
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    # Create a LocalDatum given a name and a datum type code. You
    # may also provide the optional parameters specified by the
    # Info interface.
    def create(name, datum_type, *optional); end
  end
end

# == OGC spec description
#
# A meridian used to take longitude measurements from.
class RGeo::CoordSys::CS::PrimeMeridian < ::RGeo::CoordSys::CS::Info
  # @return [PrimeMeridian] a new instance of PrimeMeridian
  def initialize(name, angular_unit, longitude, *optional); end

  # Returns the AngularUnits.
  def angular_unit; end

  # Returns the longitude value relative to the Greenwich Meridian.
  # The longitude is expressed in this objects angular units.
  def longitude; end

  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    # Create a PrimeMeridian given a name, AngularUnits, and the
    # longitude relative to the Greenwich Meridian, expressed in
    # the AngularUnits. You may also provide the optional parameters
    # specified by the Info interface.
    def create(name, angular_unit, longitude, *optional); end
  end
end

# == OGC spec description
#
# A 2D cartographic coordinate system.
class RGeo::CoordSys::CS::ProjectedCoordinateSystem < ::RGeo::CoordSys::CS::HorizontalCoordinateSystem
  # @return [ProjectedCoordinateSystem] a new instance of ProjectedCoordinateSystem
  def initialize(name, geographic_coordinate_system, projection, linear_unit, axis0, axis1, *optional); end

  # Returns the GeographicCoordinateSystem.
  def geographic_coordinate_system; end

  # Implements CoordinateSystem#get_axis
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  def get_units(index); end

  # Returns the LinearUnits. The linear unit must be the same as
  # the CS_CoordinateSystem units.
  def linear_unit; end

  # Gets the projection.
  def projection; end

  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    # Create a ProjectedCoordinateSystem given a name, a
    # GeographicCoordinateSystem, and Projection, a LinearUnit, and
    # two AxisInfo objects. The AxisInfo objects are optional and
    # may be set to nil. You may also provide the optional
    # parameters specified by the Info interface.
    def create(name, geographic_coordinate_system, projection, linear_unit, axis0, axis1, *optional); end
  end
end

# == OGC spec description
#
# A projection from geographic coordinates to projected coordinates.
class RGeo::CoordSys::CS::Projection < ::RGeo::CoordSys::CS::Info
  # @return [Projection] a new instance of Projection
  def initialize(name, class_name, parameters, *optional); end

  # Gets the projection classification name
  # (e.g. "Transverse_Mercator").
  def class_name; end

  # Iterates over the parameters of the projection.
  def each_parameter(&block); end

  # Gets an inexed parameter of the projection.
  def get_parameter(index); end

  # Gets number of parameters of the projection.
  def num_parameters; end

  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    # Create a Projection given a name, a projection class, and an
    # array of ProjectionParameter. You may also provide the
    # optional parameters specified by the Info interface.
    def create(name, class_name, parameters, *optional); end
  end
end

# == OGC spec description
#
# A named projection parameter value. The linear units of
# parameters' values match the linear units of the containing
# projected coordinate system. The angular units of parameter
# values match the angular units of the geographic coordinate
# system that the projected coordinate system is based on.
class RGeo::CoordSys::CS::ProjectionParameter < ::RGeo::CoordSys::CS::Base
  # @return [ProjectionParameter] a new instance of ProjectionParameter
  def initialize(name, value); end

  # The parameter name.
  def name; end

  # The parameter value.
  def value; end

  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    # Create a parameter given the name and value.
    def create(name, value); end
  end
end

# == OGC spec description
#
# Base interface for defining units.
#
# == Notes
#
# Normally, you will instantiate one of the subclasses LinearUnit or
# AngularUnit. However, it is possible to instantiate Unit if it is
# not clear whether the data refers to a LinearUnit or AngularUnit.
class RGeo::CoordSys::CS::Unit < ::RGeo::CoordSys::CS::Info
  # @return [Unit] a new instance of Unit
  def initialize(name, conversion_factor, *optional); end

  # This field is not part of the OGC CT spec, but is part of the
  # SFS. It is an alias of the appropriate field in the subclass,
  # i.e. LinearUnit#meters_per_unit or AngularUnit#radians_per_unit.
  def conversion_factor; end

  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    # Create a bare Unit that does not specify whether it is a
    # LinearUnit or an AngularUnit, given a unit name and a
    # conversion factor. You may also provide the optional
    # parameters specified by the Info interface.
    def create(name, conversion_factor, *optional); end
  end
end

# A datum type constant for VerticalDatum.
# The vertical datum of altitudes or heights in the atmosphere.
# These are approximations of orthometric heights obtained with the
# help of a barometer or a barometric altimeter. These values are
# usually expressed in one of the following units: meters, feet,
# millibars (used to measure pressure levels), or theta value (units
# used to measure geopotential height).
RGeo::CoordSys::CS::VD_ALTITUDE_BAROMETRIC = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# This attribute is used to support the set of datums generated for
# hydrographic engineering projects where depth measurements below
# sea level are needed. It is often called a hydrographic or a
# marine datum. Depths are measured in the direction perpendicular
# (approximately) to the actual equipotential surfaces of the
# earth's gravity field, using such procedures as echo-sounding.
RGeo::CoordSys::CS::VD_DEPTH = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# A vertical datum for ellipsoidal heights that are measured along
# the normal to the ellipsoid used in the definition of horizontal
# datum.
RGeo::CoordSys::CS::VD_ELLIPSOIDAL = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# A vertical datum of geoid model derived heights, also called
# GPS-derived heights. These heights are approximations of
# orthometric heights (H), constructed from the ellipsoidal heights
# (h) by the use of the given geoid undulation model (N) through
# the equation: H=h-N.
RGeo::CoordSys::CS::VD_GEOID_MODE_DERIVED = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# Highest possible value for vertical datum types.
RGeo::CoordSys::CS::VD_MAX = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# Lowest possible value for vertical datum types.
RGeo::CoordSys::CS::VD_MIN = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# A normal height system.
RGeo::CoordSys::CS::VD_NORMAL = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# A vertical datum for orthometric heights that are measured along
# the plumb line.
RGeo::CoordSys::CS::VD_ORTHOMETRIC = T.let(T.unsafe(nil), Integer)

# A datum type constant for VerticalDatum.
# Unspecified vertical datum type.
RGeo::CoordSys::CS::VD_OTHER = T.let(T.unsafe(nil), Integer)

# == OGC spec description
#
# A one-dimensional coordinate system suitable for vertical
# measurements.
class RGeo::CoordSys::CS::VerticalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  # @return [VerticalCoordinateSystem] a new instance of VerticalCoordinateSystem
  def initialize(name, vertical_datum, vertical_unit, axis, *optional); end

  # Implements CoordinateSystem#get_axis
  def get_axis(index); end

  # Implements CoordinateSystem#get_units
  def get_units(index); end

  # Gets the vertical datum, which indicates the measurement method.
  def vertical_datum; end

  # Gets the units used along the vertical axis. The vertical units
  # must be the same as the CS_CoordinateSystem units.
  def vertical_unit; end

  def wkt_typename; end

  private

  def wkt_content(standard_brackets); end

  class << self
    # Create a VerticalCoordinateSystem given a name, a
    # VerticalDatum, a LinearUnit, and an AxisInfo. The AxisInfo is
    # optional and may be nil. You may also provide the optional
    # parameters specified by the Info interface.
    def create(name, vertical_datum, vertical_unit, axis, *optional); end
  end
end

# == OGC spec description
#
# Procedure used to measure vertical distances.
class RGeo::CoordSys::CS::VerticalDatum < ::RGeo::CoordSys::CS::Datum
  def wkt_typename; end

  private

  def wkt_content(_); end

  class << self
    # Create a VerticalDatum given a name and a datum type code.
    # You may also provide the optional parameters specified by the
    # Info interface.
    def create(name, datum_type, *optional); end
  end
end

# == OGC spec description
#
# Parameters for a geographic transformation into WGS84. The Bursa
# Wolf parameters should be applied to geocentric coordinates, where
# the X axis points towards the Greenwich Prime Meridian, the Y axis
# points East, and the Z axis points North.
class RGeo::CoordSys::CS::WGS84ConversionInfo < ::RGeo::CoordSys::CS::Base
  # @return [WGS84ConversionInfo] a new instance of WGS84ConversionInfo
  def initialize(dx, dy, dz, ex, ey, ez, ppm); end

  # Bursa Wolf shift in meters.
  def dx; end

  # Bursa Wolf shift in meters.
  def dy; end

  # Bursa Wolf shift in meters.
  def dz; end

  # Bursa Wolf rotation in arc seconds.
  def ex; end

  # Bursa Wolf rotation in arc seconds.
  def ey; end

  # Bursa Wolf rotation in arc seconds.
  def ez; end

  # Bursa Wolf scaling in in parts per million.
  def ppm; end

  def to_wkt(standard_brackets = T.unsafe(nil)); end

  class << self
    # Create the horizontal datum shift transformation into WGS84,
    # given the seven Bursa Wolf parameters.
    # The Bursa Wolf shift should be in meters, the rotation in arc
    # seconds, and the scaling in parts per million.
    def create(dx, dy, dz, ex, ey, ez, ppm); end
  end
end

class RGeo::CoordSys::CS::WKTParser
  # @return [WKTParser] a new instance of WKTParser
  def initialize(str); end

  def consume_tokentype(type); end

  # Returns the value of attribute cur_token.
  def cur_token; end

  def expect_tokentype(type); end
  def next_token; end
  def parse(containing_type = T.unsafe(nil)); end
end

class RGeo::CoordSys::CS::WKTParser::ArgumentList
  # @return [ArgumentList] a new instance of ArgumentList
  def initialize; end

  def <<(value); end
  def assert_empty; end
  def create_optionals; end
  def find_all(klass); end
  def find_first(klass); end
  def shift(klass = T.unsafe(nil)); end
end

class RGeo::CoordSys::CS::WKTParser::AuthorityClause
  # @return [AuthorityClause] a new instance of AuthorityClause
  def initialize(name, code); end

  def to_a; end
end

class RGeo::CoordSys::CS::WKTParser::ExtensionClause
  # @return [ExtensionClause] a new instance of ExtensionClause
  def initialize(key, value); end

  def key; end
  def value; end
end

class RGeo::CoordSys::CS::WKTParser::QuotedString < ::String; end
class RGeo::CoordSys::CS::WKTParser::TypeString < ::String; end

# Spatial reference system database classes must implement these methods:
#   get
#   clear_cache
#
# See SrOrg and UrlReader for implementations of SRSDatabase classes.
#
# Retrieve an Entry given an identifier. The identifier is usually
# a numeric spatial reference ID (SRID), but could be a string
# value for certain database types.
#   get(identifier)
#
# Clear any cache utilized by this database.
#   clear_cache
module RGeo::CoordSys::SRSDatabase; end

# An entry in a spatial reference system database.
# Every entry has an identifier, but all the other attributes are
# optional and may or may not be present depending on the database.
class RGeo::CoordSys::SRSDatabase::Entry
  # Create an entry.
  # You must provide an identifier, which may be numeric or a
  # string. The data hash should contain any other attributes,
  # keyed by symbol.
  #
  # Some attribute inputs have special behaviors:
  #
  # [<tt>:coord_sys</tt>]
  #   You can pass a CS coordinate system object, or a string in
  #   WKT format.
  # [<tt>:proj4</tt>]
  #   You can pass a Proj4 object, or a proj4-format string.
  # [<tt>:name</tt>]
  #   If the name is not provided directly, it is taken from the
  #   coord_sys.
  # [<tt>:authority</tt>]
  #   If the authority name is not provided directly, it is taken
  #   from the coord_sys.
  # [<tt>:authority_code</tt>]
  #   If the authority code is not provided directly, it is taken
  #   from the coord_sys.
  #
  # @return [Entry] a new instance of Entry
  def initialize(ident, data = T.unsafe(nil)); end

  # The authority name, if present. Example: "epsg".
  def authority; end

  # The authority code, e.g. an EPSG code.
  def authority_code; end

  # The CS::CoordinateSystem object.
  def coord_sys; end

  # A human-readable description for this coordinate system.
  def description; end

  # The database key or identifier.
  def identifier; end

  # A human-readable name for this coordinate system.
  def name; end

  # The Proj4 object.
  def proj4; end
end

# A spatial reference database implementation that fetches data
# from the spatialreference.org website.
class RGeo::CoordSys::SRSDatabase::SrOrg
  # Create a database backed by the given catalog of the
  # spatialreference.org website. Catalogs currently supported by
  # spatialreference.org are "epsg", "esri", "iau2000" and "sr-org".
  #
  # Options:
  #
  # [<tt>:cache</tt>]
  #   If set to true, lookup results are cached so if the same URL
  #   is requested again, the result is served from cache rather
  #   than issuing another HTTP request. Default is false.
  #
  # @return [SrOrg] a new instance of SrOrg
  def initialize(catalog, opts = T.unsafe(nil)); end

  # The spatialreference.org catalog used by this database.
  def catalog; end

  # Clear the cache if one exists.
  def clear_cache; end

  # Retrieve the Entry from a spatialreference.org catalog given an
  # integer ID.
  def get(ident); end
end

# A spatial reference database implementation that fetches data from
# internet URLs.
class RGeo::CoordSys::SRSDatabase::UrlReader
  # Create a URL-based spatial reference database.
  #
  # Options:
  #
  # [<tt>:cache</tt>]
  #   If set to true, lookup results are cached so if the same URL
  #   is requested again, the result is served from cache rather
  #   than issuing another HTTP request. Default is false.
  #
  # @return [UrlReader] a new instance of UrlReader
  def initialize(opts = T.unsafe(nil)); end

  # Clear the cache if one is present.
  def clear_cache; end

  # Retrieve the given URL and return an Entry.
  # Returns nil if the URL cannot be read as an OGC WKT or Proj4
  # coordinate system
  def get(ident); end
end

# All RGeo errors are members of this namespace.
module RGeo::Error; end

# RGeo error specific to the GEOS implementation.
class RGeo::Error::GeosError < ::RGeo::Error::RGeoError; end

# The specified geometry is invalid
class RGeo::Error::InvalidGeometry < ::RGeo::Error::RGeoError; end

# Parsing failed
class RGeo::Error::ParseError < ::RGeo::Error::RGeoError; end

# Base class for all RGeo-related exceptions
class RGeo::Error::RGeoError < ::RuntimeError; end

# The specified operation is not supported or not implemented
class RGeo::Error::UnsupportedOperation < ::RGeo::Error::RGeoError; end

module RGeo::Feature
  class << self
    # Cast the given object according to the given parameters, if
    # possible, and return the resulting object. If the requested cast
    # is not possible, nil is returned.
    #
    # Parameters may be provided as a hash, or as separate arguments.
    # Hash keys are as follows:
    #
    # [<tt>:factory</tt>]
    #   Set the factory to the given factory. If this argument is not
    #   given, the original object's factory is kept.
    # [<tt>:type</tt>]
    #   Cast to the given type, which must be a module in the
    #   RGeo::Feature namespace. If this argument is not given, the
    #   result keeps the same type as the original.
    # [<tt>:project</tt>]
    #   If this is set to true, and both the original and new factories
    #   support proj4 projections, then the cast will also cause the
    #   coordinates to be transformed between those two projections.
    #   If set to false, the coordinates are not modified. Default is
    #   false.
    # [<tt>:keep_subtype</tt>]
    #   Value must be a boolean indicating whether to keep the subtype
    #   of the original. If set to false, casting to a particular type
    #   always casts strictly to that type, even if the old type is a
    #   subtype of the new type. If set to true, the cast retains the
    #   subtype in that case. For example, casting a LinearRing to a
    #   LineString will normally yield a LineString, even though
    #   LinearRing is already a more specific subtype. If you set this
    #   value to true, the casted object will remain a LinearRing.
    #   Default is false.
    # [<tt>:force_new</tt>]
    #   Always return a newly-created object, even if neither the type
    #   nor factory is modified. Normally, if this is set to false, and
    #   a cast is not set to modify either the factory or type, the
    #   original object itself is returned. Setting this flag to true
    #   causes cast to return a clone in that case. Default is false.
    #
    # You may also pass the new factory, the new type, and the flags
    # as separate arguments. In this case, the flag names must be
    # passed as symbols, and their effect is the same as setting their
    # values to true. You can even combine separate arguments and hash
    # arguments. For example, the following three calls are equivalent:
    #
    #  RGeo::Feature.cast(geom, :type => RGeo::Feature::Point, :project => true)
    #  RGeo::Feature.cast(geom, RGeo::Feature::Point, :project => true)
    #  RGeo::Feature.cast(geom, RGeo::Feature::Point, :project)
    #
    # RGeo provides a default casting algorithm. Individual feature
    # implementation factories may override this and customize the
    # casting behavior by defining the override_cast method. See
    # RGeo::Feature::Factory#override_cast for more details.
    def cast(obj, *params); end
  end
end

# == SFS 1.1 Description
#
# A Curve is a 1-dimensional geometric object usually stored as a
# sequence of Points, with the subtype of Curve specifying the form of
# the interpolation between Points. This part of ISO 19125 defines only
# one subclass of Curve, LineString, which uses linear interpolation
# between Points.
#
# A Curve is a 1-dimensional geometric object that is the homeomorphic
# image of a real, closed interval D=[a,b] under a mapping f:[a,b]->R2.
#
# A Curve is simple if it does not pass through the same Point twice.
#
# A Curve is closed if its start Point is equal to its end Point.
#
# The boundary of a closed Curve is empty.
#
# A Curve that is simple and closed is a Ring.
#
# The boundary of a non-closed Curve consists of its two end Points.
#
# A Curve is defined as topologically closed.
#
# == Notes
#
# Curve is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# Some implementations may support higher dimensional points.
module RGeo::Feature::Curve
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # Returns true if this Curve is closed [StartPoint() = EndPoint()].
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def closed?; end

  # === SFS 1.1 Description
  #
  # The end Point of this Curve.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  def end_point; end

  # @return [Boolean]
  def is_closed?; end

  # @return [Boolean]
  def is_ring?; end

  # === SFS 1.1 Description
  #
  # The length of this Curve in its associated spatial reference.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  def length; end

  # === SFS 1.1 Description
  #
  # Returns true if this Curve is closed [StartPoint() = EndPoint()]
  # and this Curve is simple (does not pass through the same Point
  # more than once).
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def ring?; end

  # === SFS 1.1 Description
  #
  # The start Point of this Curve.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  def start_point; end
end

# This is a standard interface for factories of features.
# Generally, each Feature implementation will implement these
# methods as a standard way to create features.
#
# If the implementation is unable to create the given feature,
# it should generally return nil. Implementations may also choose to
# raise an exception on failure.
#
# Some implementations may extend this interface to provide facilities
# for creating additional objects according to the capabilities
# provided by that implementation. Examples might include
# higher-dimensional coordinates or additional subclasses not
# explicitly required by the Simple Features Specification.
#
# Factory is defined as a module and is provided primarily for the
# sake of documentation. Implementations need not necessarily include
# this module itself. Therefore, you should not depend on the result
# of <tt>is_a?(Factory)</tt> to check type. However, to support
# testing for factory-ness, the <tt>Factory::Instance</tt> submodule
# is provided. All factory implementation classes MUST include
# <tt>Factory::Instance</tt>, and you may use it in <tt>is_a?</tt>,
# <tt>===</tt>, and case-when constructs.
module RGeo::Feature::Factory
  # Create a feature of type GeometryCollection.
  # The elems should be an Enumerable of Geometry objects.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  def collection(elems); end

  # Returns the coordinate system specification for the features
  # created by this factory, or nil if there is no such coordinate
  # system.
  #
  # NOTE: This is a required method of the factory interface, but the
  # coordinate system classes themselves are not yet available, so
  # implementations should just return nil for now.
  def coord_sys; end

  # Create a feature of type Line.
  # The given point arguments should be Point objects, or objects
  # that can be cast to Point.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  def line(start, stop); end

  # Create a feature of type LineString.
  # The given points argument should be an Enumerable of Point
  # objects, or objects that can be cast to Point.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  def line_string(points); end

  # Create a feature of type LinearRing.
  # The given points argument should be an Enumerable of Point
  # objects, or objects that can be cast to Point.
  # If the first and last points are not equal, the ring is
  # automatically closed by appending the first point to the end of the
  # string.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  def linear_ring(points); end

  # Create a feature of type MultiLineString.
  # The elems should be an Enumerable of objects that are or can be
  # cast to LineString or any of its subclasses.
  # Returns nil if any of the contained geometries is not a
  # LineString, which would break the MultiLineString contract.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  def multi_line_string(elems); end

  # Create a feature of type MultiPoint.
  # The elems should be an Enumerable of Point objects, or objects
  # that can be cast to Point.
  # Returns nil if any of the contained geometries is not a Point,
  # which would break the MultiPoint contract.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  def multi_point(elems); end

  # Create a feature of type MultiPolygon.
  # The elems should be an Enumerable of objects that are or can be
  # cast to Polygon or any of its subclasses.
  # Returns nil if any of the contained geometries is not a Polygon,
  # which would break the MultiPolygon contract.
  # Also returns nil if any of the other assertions for MultiPolygon
  # are not met, e.g. if any of the polygons overlap.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  def multi_polygon(elems); end

  # This is an optional method that may be implemented to customize
  # casting for this factory. Basically, RGeo defines standard ways
  # to cast certain types of objects from one factory to another and
  # one SFS type to another. However, a factory may choose to
  # override how things are casted TO its implementation using this
  # method. It can do this to optimize certain casting cases, or
  # implement special cases particular to this factory.
  #
  # This method will be called (if defined) on the destination
  # factory, and will be passed the original object (which may or may
  # not already be created by this factory), the SFS feature type
  # (which again may or may not already be the type of the original
  # object), and a hash of additional flags. These flags are:
  #
  # [<tt>:keep_subtype</tt>]
  #   indicates whether to keep the subtype if casting to a supertype
  #   of the current type
  # [<tt>:force_new</tt>]
  #   indicates whether to force the creation of a new object even if
  #   the original is already of the desired factory and type
  # [<tt>:project</tt>]
  #   indicates whether to project the coordinates from the source to
  #   the destination proj4 coordinate system, if available
  #
  # It should return either a casted result object, false, or nil.
  # A nil return value indicates that casting should be forced to
  # fail (and RGeo::Feature.cast will return nil).
  # A false return value indicates that this method declines to
  # override the casting algorithm, and RGeo should use its default
  # algorithm to cast the object. Therefore, by default, you should
  # return false.
  def override_cast(original, type, flags); end

  # Parse the given string in well-known-binary format and return the
  # resulting feature. Returns nil if the string couldn't be parsed.
  def parse_wkb(str); end

  # Parse the given string in well-known-text format and return the
  # resulting feature. Returns nil if the string couldn't be parsed.
  def parse_wkt(str); end

  # Create a feature of type Point.
  # The x and y parameters should be Float values.
  #
  # The extra parameters should be the Z and/or M coordinates, if
  # supported. If both Z and M coordinates are supported, Z should
  # be passed first.
  def point(x, y, *extra); end

  # Create a feature of type Polygon.
  # The outer_ring should be a LinearRing, or an object that can be
  # cast to LinearRing.
  # The inner_rings should be a possibly empty Enumerable of
  # LinearRing (or objects that can be casted to LinearRing).
  # You may also pass nil to indicate no inner rings.
  #
  # Although implementations are free to attempt to handle input
  # objects that are not of this factory, strictly speaking, the
  # result of building geometries from objects of the wrong factory
  # is undefined.
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end

  # Returns a RGeo::CoordSys::Proj4 representing the projection for
  # the coordinate system of features created by this factory, or nil
  # if there is no such proj4 projection.
  def proj4; end

  # Returns meta-information about this factory, by key. This
  # information may involve support for optional functionality,
  # properties of the coordinate system, or other characteristics.
  #
  # Each property has a symbolic name. Names that have no periods are
  # considered well-known names and are reserved for use by RGeo. If
  # you want to define your own properties, use a name that is
  # namespaced with periods, such as <tt>:'mycompany.myprop'</tt>.
  #
  # Property values are dependent on the individual property.
  # Generally, properties that involve testing for functionality
  # should return true if the functionality is support, or false or
  # nil if not. A property value could also invlove different values
  # indicating different levels of support. In any case, the factory
  # should return nil for property names it does not recognize. This
  # value is considered the "default" or "no value" value.
  #
  # Currently defined well-known properties are:
  #
  # [<tt>:has_z_coordinate</tt>]
  #   Set to true if geometries created by this factory include a Z
  #   coordinate, and the Point#z method is available.
  # [<tt>:has_m_coordinate</tt>]
  #   Set to true if geometries created by this factory include a M
  #   coordinate, and the Point#m method is available.
  # [<tt>:is_cartesian</tt>]
  #   Set to true if this Factory guarantees that it operates in
  #   Cartesian geometry. If false or nil, no such guarantee is made,
  #   though it is possible the geometries may still be Cartesian.
  # [<tt>:is_geographic</tt>]
  #   Set to true if this Factory's coordinate system is meant to be
  #   interpreted as x=longitude and y=latitude. If false or nil, no
  #   information is present about whether the coordinate system is
  #   meant to be so interpreted.
  def property(name); end
end

# All factory implementations MUST include this submodule.
# This serves as a marker that may be used to test an object for
# factory-ness.
module RGeo::Feature::Factory::Instance; end

# A FactoryGenerator is a callable object (usually a Proc) that
# takes a configuration as a hash and returns a factory. These are
# often used, e.g., by parsers to determine what factory the parsed
# geometry should have.
#
# See the call method for a list of common configuration parameters.
# Different generators will support different parameters. There is
# no mechanism defined to reflect on the parameters understood by a
# factory generator.
#
# Many of the implementations provide a factory method for creating
# factories. For example, RGeo::Cartesian.preferred_factory can be
# called to create a factory using the preferred Cartesian
# implementation. Thus, to get a corresponding factory generator,
# you can use the <tt>method</tt> method. e.g.
#
#  factory_generator = RGeo::Cartesian.method(:preferred_factory)
#
# FactoryGenerator is defined as a module and is provided
# primarily for the sake of documentation. Implementations need not
# necessarily include this module itself. Therefore, you should not
# depend on the kind_of? method to determine if an object is a
# factory generator.
module RGeo::Feature::FactoryGenerator
  # Generate a factory given a configuration as a hash.
  #
  # If the generator does not recognize or does not support a given
  # configuration value, the behavior is usually determined by the
  # <tt>:strict</tt> configuration element. If <tt>strict</tt> is
  # set to true, the generator should fail fast by returning nil or
  # raising an exception. If it is set to false, the generator should
  # attempt to do the best it can, even if it means returning a
  # factory that does not match the requested configuration.
  #
  # Common parameters are as follows. These are intended as a
  # recommendation only. There is no hard requirement for any
  # particular factory generator to support them.
  #
  # [<tt>:strict</tt>]
  #   If true, return nil or raise an exception if any configuration
  #   was not recognized or not supportable. Otherwise, if false,
  #   the generator should attempt to do its best to return some
  #   viable factory, even if it does not strictly match the
  #   requested configuration. Default is usually false.
  # [<tt>:srid</tt>]
  #   The SRID for the factory and objects it creates.
  #   Default is usually 0.
  # [<tt>:proj4</tt>]
  #   The coordinate system in Proj4 format, either as a
  #   CoordSys::Proj4 object or as a string or hash representing the
  #   proj4 format. This is usually an optional parameter; the default
  #   is usually nil.
  # [<tt>:coord_sys</tt>]
  #   The coordinate system in OGC form, either as a subclass of
  #   CoordSys::CS::CoordinateSystem, or as a string in WKT format.
  #   This is usually an optional parameter; the default is usually
  #   nil.
  # [<tt>:srs_database</tt>]
  #   If provided, look up the Proj4 and OGC coordinate systems from
  #   the given database and SRID.
  # [<tt>:has_z_coordinate</tt>]
  #   Support Z coordinates. Default is usually false.
  # [<tt>:has_m_coordinate</tt>]
  #   Support M coordinates. Default is usually false.
  def call(config = T.unsafe(nil)); end

  class << self
    # Return a new FactoryGenerator that calls the given delegate, but
    # modifies the configuration passed to it. You can provide defaults
    # for configuration values not explicitly specified, and you can
    # force certain values to override the given configuration.
    def decorate(delegate, default_config = T.unsafe(nil), force_config = T.unsafe(nil)); end

    # Return a new FactoryGenerator that always returns the given
    # factory.
    def single(factory); end
  end
end

# == SFS 1.1 Description
#
# Geometry is the root class of the hierarchy. Geometry is an abstract
# (non-instantiable) class.
#
# The instantiable subclasses of Geometry defined in this International
# Standard are restricted to 0, 1 and 2-dimensional geometric objects
# that exist in 2-dimensional coordinate space (R2).
#
# All instantiable Geometry classes described in this part of ISO 19125
# are defined so that valid instances of a Geometry class are
# topologically closed, i.e. all defined geometries include their
# boundary.
#
# == Notes
#
# Geometry is defined as a module and is provided primarily for the
# sake of documentation. Implementations need not necessarily include
# this module itself. Therefore, you should not depend on the result
# of <tt>is_a?(Geometry)</tt> to check type. Instead, use the
# provided check_type class method (or === operator) defined in the
# Type module.
#
# Some implementations may support higher dimensional objects or
# coordinate systems, despite the limits of the SFS.
#
# == Forms of equivalence
#
# The Geometry model defines three forms of equivalence.
#
# * <b>Spatial equivalence</b> is the weakest form of equivalence,
#   indicating that the objects represent the same region of space,
#   but may be different representations of that region. For example,
#   POINT(0 0) and a MULTIPOINT(0 0) are spatially equivalent, as are
#   LINESTRING(0 0, 10 10) and
#   GEOMETRYCOLLECTION(POINT(0 0), LINESTRING(0 0, 10 10, 0 0)).
#   As a general rule, objects must have factories that are
#   Factory#eql? in order to be spatially equivalent.
#
# * <b>Representational equivalence</b> is a stronger form, indicating
#   that the objects have the same representation, but may be
#   different objects. All representationally equivalent objects are
#   spatially equivalent, but not all spatially equivalent objects are
#   representationally equivalent. For example, none of the examples
#   in the spatial equivalence section above are representationally
#   equivalent. However, two separate objects that both represent
#   POINT(1 2) are representationally equivalent as well as spatially
#   equivalent.
#
# * <b>Objective equivalence</b> is the strongest form, indicating
#   that the references refer to the same object. Of course, all
#   pairs of references with the same objective identity are also
#   both representationally and spatially equivalent.
#
# Different methods test for different types of equivalence:
#
# * <tt>equals?</tt> and <tt>==</tt> test for spatial equivalence.
# * <tt>rep_equals?</tt> and <tt>eql?</tt> test for representational
#   equivalence.
# * <tt>equal?</tt> tests for objective equivalence.
#
# All ruby objects must provide a suitable test for objective
# equivalence. Normally, this is simply provided by the Ruby Object
# base class. Geometry implementations should normally also provide
# tests for representational and spatial equivalence, if possible.
# The <tt>==</tt> operator and the <tt>eql?</tt> method are standard
# Ruby methods that are often expected to be usable for every object.
# Therefore, if an implementation cannot provide a suitable test for
# their equivalence types, they must degrade to use a stronger form
# of equivalence.
module RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  # If the given rhs is a geometry object, this operator must behave
  # the same as the intersection method. The behavior for other rhs
  # types is not specified; an implementation may choose to provide
  # additional capabilities as appropriate.
  def *(rhs); end

  # If the given rhs is a geometry object, this operator must behave
  # the same as the union method. The behavior for other rhs types
  # is not specified; an implementation may choose to provide
  # additional capabilities as appropriate.
  def +(rhs); end

  # If the given rhs is a geometry object, this operator must behave
  # the same as the difference method. The behavior for other rhs
  # types is not specified; an implementation may choose to provide
  # additional capabilities as appropriate.
  def -(rhs); end

  # This operator should behave almost the same as the equals? method,
  # with two key differences.
  #
  # First, the == operator is required to handle rhs values that are
  # not geometry objects (returning false in such cases) in order to
  # fulfill the standard Ruby contract for the == operator, whereas
  # the equals? method may assume that any rhs is a geometry.
  #
  # Second, the == operator should always be defined. That is, it
  # should never raise Error::UnsupportedOperation. In cases where
  # the underlying implementation cannot provide a spatial equivalence
  # test, the == operator must fall back on representational or
  # objective equivalence.
  def ==(rhs); end

  # === SFS 1.1 Description
  #
  # Exports this geometric object to a specific Well-known Binary
  # Representation of Geometry.
  #
  # === Notes
  #
  # Returns a binary string.
  #
  # @raise [Error::UnsupportedOperation]
  def as_binary; end

  # === SFS 1.1 Description
  #
  # Exports this geometric object to a specific Well-known Text
  # Representation of Geometry.
  #
  # === Notes
  #
  # Returns an ASCII string.
  #
  # @raise [Error::UnsupportedOperation]
  def as_text; end

  # === SFS 1.1 Description
  #
  # Returns the closure of the combinatorial boundary of this geometric
  # object. Because the result of this function is a closure, and hence
  # topologically closed, the resulting boundary can be represented using
  # representational Geometry primitives.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # @raise [Error::UnsupportedOperation]
  def boundary; end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents all Points whose distance
  # from this geometric object is less than or equal to distance.
  # Calculations are in the spatial reference system of this geometric
  # object.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # @raise [Error::UnsupportedOperation]
  def buffer(_distance_); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially contains"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def contains?(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the convex hull of this
  # geometric object.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # @raise [Error::UnsupportedOperation]
  def convex_hull; end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially crosses"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def crosses?(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the Point set
  # difference of this geometric object with another_geometry.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of performing
  # operations on objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  def difference(another_geometry); end

  # === SFS 1.1 Description
  #
  # The inherent dimension of this geometric object, which must be less
  # than or equal to the coordinate dimension. This specification is
  # restricted to geometries in 2-dimensional coordinate space.
  #
  # === Notes
  #
  # Returns an integer. This value is -1 for an empty geometry, 0 for
  # point geometries, 1 for curves, and 2 for surfaces.
  #
  # @raise [Error::UnsupportedOperation]
  def dimension; end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is "spatially disjoint" from
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def disjoint?(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns the shortest distance between any two Points in the two
  # geometric objects as calculated in the spatial reference system of
  # this geometric object.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of measuring the
  # distance between objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  def distance(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is the empty Geometry. If true,
  # then this geometric object represents the empty point set for the
  # coordinate space.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def empty?; end

  # === SFS 1.1 Description
  #
  # The minimum bounding box for this Geometry, returned as a Geometry.
  # The polygon is defined by the corner points of the bounding box
  # [(MINX, MINY), (MAXX, MINY), (MAXX, MAXY), (MINX, MAXY), (MINX, MINY)].
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # @raise [Error::UnsupportedOperation]
  def envelope; end

  # This method should behave almost the same as the rep_equals?
  # method, with two key differences.
  #
  # First, the <tt>eql?</tt> method is required to handle rhs values
  # that are not geometry objects (returning false in such cases) in
  # order to fulfill the standard Ruby contract for the method,
  # whereas the rep_equals? method may assume that any rhs is a
  # geometry.
  #
  # Second, the <tt>eql?</tt> method should always be defined. That
  # is, it should never raise Error::UnsupportedOperation. In cases
  # where the underlying implementation cannot provide a
  # representational equivalence test, this method must fall back on
  # objective equivalence.
  #
  # @return [Boolean]
  def eql?(rhs); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is "spatially equal" to
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def equals?(another_geometry); end

  # Returns a factory for creating features related to this one.
  # This does not necessarily need to be the same factory that created
  # this object, but it should create objects that are "compatible"
  # with this one. (i.e. they should be in the same spatial reference
  # system by default, and it should be possible to perform relational
  # operations on them.)
  #
  # @raise [Error::UnsupportedOperation]
  def factory; end

  # === SFS 1.1 Description
  #
  # Returns the instantiable subtype of Geometry of which this
  # geometric object is an instantiable member.
  #
  # === Notes
  #
  # Returns one of the type modules in RGeo::Feature. e.g. a point
  # object would return RGeo::Feature::Point. Note that this is
  # different from the SFS specification, which stipulates that the
  # string name of the type is returned. To obtain the name string,
  # call the +type_name+ method of the returned module.
  #
  # @raise [Error::UnsupportedOperation]
  def geometry_type; end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the Point set
  # intersection of this geometric object with another_geometry.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of performing
  # operations on objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  def intersection(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially intersects"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def intersects?(another_geometry); end

  # @return [Boolean]
  def is_empty?; end

  # @return [Boolean]
  def is_simple?; end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially overlaps"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def overlaps?(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is spatially related to
  # another_geometry by testing for intersections between the interior,
  # boundary and exterior of the two geometric objects as specified by
  # the values in the intersection_pattern_matrix.
  #
  # === Notes
  #
  # The intersection_pattern_matrix is provided as a nine-character
  # string in row-major order, representing the dimensionalities of
  # the different intersections in the DE-9IM. Supported characters
  # include T, F, *, 0, 1, and 2.
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def relate?(another_geometry, _intersection_pattern_matrix_); end

  # Returns true if this geometric object is representationally
  # equivalent to the given object.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def rep_equals?(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object has no anomalous geometric
  # points, such as self intersection or self tangency. The description
  # of each instantiable geometric class will include the specific
  # conditions that cause an instance of that class to be classified as
  # not simple.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def simple?; end

  # === SFS 1.1 Description
  #
  # Returns the Spatial Reference System ID for this geometric object.
  #
  # === Notes
  #
  # Returns an integer.
  #
  # This will normally be a foreign key to an index of reference systems
  # stored in either the same or some other datastore.
  #
  # @raise [Error::UnsupportedOperation]
  def srid; end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the Point set symmetric
  # difference of this geometric object with another_geometry.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of performing
  # operations on objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  def sym_difference(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object "spatially touches"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def touches?(another_geometry); end

  # Unions a collection of Geometry or a single Geometry
  # (which may be a collection) together. By using this
  # special-purpose operation over a collection of geometries
  # it is possible to take advantage of various optimizations
  # to improve performance. Heterogeneous GeometryCollections
  # are fully supported.
  #
  # This is not a standard SFS method, but when it is available
  # in GEOS, it is a very performant way to union all the
  # geometries in a collection. GEOS version 3.3 or greater
  # is required. If the feature is not available, unary_union
  # returns nil.
  #
  # @raise [Error::UnsupportedOperation]
  def unary_union; end

  # === SFS 1.1 Description
  #
  # Returns a geometric object that represents the Point set
  # union of this geometric object with another_geometry.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of performing
  # operations on objects from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  def union(another_geometry); end

  # === SFS 1.1 Description
  #
  # Returns true if this geometric object is "spatially within"
  # another_geometry.
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # Although implementations are free to attempt to handle
  # another_geometry values that do not share the same factory as
  # this geometry, strictly speaking, the result of comparing objects
  # from different factories is undefined.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def within?(another_geometry); end
end

# == SFS 1.1 Description
#
# A GeometryCollection is a geometric object that is a collection of 1
# or more geometric objects.
#
# All the elements in a GeometryCollection shall be in the same Spatial
# Reference. This is also the Spatial Reference for the GeometryCollection.
#
# GeometryCollection places no other constraints on its elements.
# Subclasses of GeometryCollection may restrict membership based on
# dimension and may also place other constraints on the degree of spatial
# overlap between elements.
#
# == Notes
#
# GeometryCollection is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  extend ::RGeo::Feature::Type

  # Returns the Nth geometry in this GeometryCollection, or nil if the
  # given N is out of range. N is zero-based.
  #
  # This behaves slightly different from GeometryCollection#geometry_n.
  # GeometryCollection#geometry_n accepts only nonnegative indexes,
  # as specified by the SFS. However, GeometryCollection#[] also accepts
  # negative indexes counting backwards from the end of the collection,
  # the same way Ruby's array indexing works. Hence, geometry_n(-1)
  # returns nil, where [-1] returns the last element of the collection.
  #
  # @raise [Error::UnsupportedOperation]
  def [](n); end

  # Iterates over the geometries of this GeometryCollection.
  #
  # This is not a standard SFS method, but is provided so that a
  # GeometryCollection can behave as a Ruby enumerable.
  # Note that all GeometryCollection implementations must also
  # include the Enumerable mixin.
  #
  # @raise [Error::UnsupportedOperation]
  def each(&block); end

  # === SFS 1.1 Description
  #
  # Returns the Nth geometry in this GeometryCollection.
  #
  # === Notes
  #
  # Returns an object that supports the Geometry interface, or nil
  # if the given N is out of range. N is zero-based.
  # Also note that this method is different from GeometryCollection#[]
  # in that it does not support negative indexes.
  #
  # @raise [Error::UnsupportedOperation]
  def geometry_n(n); end

  # Nodes the linework in a list of Geometries
  #
  # @raise [Error::UnsupportedOperation]
  def node; end

  # === SFS 1.1 Description
  #
  # Returns the number of geometries in this GeometryCollection.
  #
  # === Notes
  #
  # Returns an integer.
  #
  # @raise [Error::UnsupportedOperation]
  def num_geometries; end

  # Alias of the num_geometries method.
  def size; end
end

# All geometry implementations MUST include this submodule.
# This serves as a marker that may be used to test an object for
# feature-ness.
module RGeo::Feature::Instance; end

# == SFS 1.1 Description
#
# A Line is a LineString with exactly 2 Points.
#
# == Notes
#
# Line is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::Line
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  extend ::RGeo::Feature::Type
end

# == SFS 1.1 Description
#
# A LineString is a Curve with linear interpolation between Points.
# Each consecutive pair of Points defines a Line segment.
#
# == Notes
#
# LineString is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::LineString
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # The number of Points in this LineString.
  #
  # === Notes
  #
  # Returns an integer.
  #
  # @raise [Error::UnsupportedOperation]
  def num_points; end

  # === SFS 1.1 Description
  #
  # Returns the specified Point N in this LineString.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface, or nil
  # if the given N is out of range. N is zero-based.
  # Does not support negative indexes.
  #
  # @raise [Error::UnsupportedOperation]
  def point_n(n); end

  # Returns the constituent points as an array of objects that
  # support the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  def points; end
end

# == SFS 1.1 Description
#
# A LinearRing is a LineString that is both closed and simple.
#
# == Notes
#
# LinearRing is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::LinearRing
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  extend ::RGeo::Feature::Type

  # Returns +true+ if the ring is oriented in a counter clockwise direction
  # otherwise returns +false+.
  #
  # == Notes
  #
  # Not a standard SFS method for linear rings, but added for convenience.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def ccw?; end
end

# == SFS 1.1 Description
#
# A MultiCurve is a 1-dimensional GeometryCollection whose elements are
# Curves.
#
# MultiCurve is a non-instantiable class in this specification; it
# defines a set of methods for its subclasses and is included for
# reasons of extensibility.
#
# A MultiCurve is simple if and only if all of its elements are simple
# and the only intersections between any two elements occur at Points
# that are on the boundaries of both elements.
#
# The boundary of a MultiCurve is obtained by applying the "mod 2"
# union rule: A Point is in the boundary of a MultiCurve if it is in
# the boundaries of an odd number of elements of the MultiCurve.
#
# A MultiCurve is closed if all of its elements are closed. The
# boundary of a closed MultiCurve is always empty.
#
# A MultiCurve is defined as topologically closed.
#
# == Notes
#
# MultiCurve is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::MultiCurve
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # Returns true if this MultiCurve is closed [StartPoint() = EndPoint()
  # for each Curve in this MultiCurve].
  #
  # === Notes
  #
  # Returns a boolean value. Note that this is different from the SFS
  # specification, which stipulates an integer return value.
  #
  # @raise [Error::UnsupportedOperation]
  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def is_closed?; end

  # === SFS 1.1 Description
  #
  # The Length of this MultiCurve which is equal to the sum of the
  # lengths of the element Curves.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  def length; end
end

# == SFS 1.1 Description
#
# A MultiLineString is a MultiCurve whose elements are LineStrings.
#
# == Notes
#
# MultiLineString is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  extend ::RGeo::Feature::Type
end

# == SFS 1.1 Description
#
# A MultiPoint is a 0-dimensional GeometryCollection. The elements of
# a MultiPoint are restricted to Points. The Points are not connected
# or ordered.
#
# A MultiPoint is simple if no two Points in the MultiPoint are equal
# (have identical coordinate values).
#
# The boundary of a MultiPoint is the empty set.
#
# == Notes
#
# MultiPoint is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type
end

# == SFS 1.1 Description
#
# A MultiPolygon is a MultiSurface whose elements are Polygons.
#
# The assertions for MultiPolygons are as follows.
#
# a) The interiors of 2 Polygons that are elements of a MultiPolygon
# may not intersect.
#
# b) The boundaries of any 2 Polygons that are elements of a
# MultiPolygon may not "cross" and may touch at only a finite number
# of Points. NOTE: Crossing is prevented by assertion (a) above.
#
# c) A MultiPolygon is defined as topologically closed.
#
# d) A MultiPolygon may not have cut lines, spikes or punctures, a
# MultiPolygon is a regular closed Point set:
#
# e) The interior of a MultiPolygon with more than 1 Polygon is not
# connected, the number of connected components of the interior of a
# MultiPolygon is equal to the number of Polygons in the MultiPolygon.
#
# The boundary of a MultiPolygon is a set of closed Curves
# (LineStrings) corresponding to the boundaries of its element
# Polygons. Each Curve in the boundary of the MultiPolygon is in the
# boundary of exactly 1 element Polygon, and every Curve in the
# boundary of an element Polygon is in the boundary of the
# MultiPolygon.
#
# NOTE: The subclass of Surface named Polyhedral Surface is a faceted
# Surface whose facets are Polygons. A Polyhedral Surface is not a
# MultiPolygon because it violates the rule for MultiPolygons that the
# boundaries of the element Polygons intersect only at a finite number
# of Points.
#
# == Notes
#
# MultiPolygon is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  extend ::RGeo::Feature::Type
end

# == SFS 1.1 Description
#
# A MultiSurface is a 2-dimensional GeometryCollection whose elements
# are Surfaces. The interiors of any two Surfaces in a MultiSurface may
# not intersect. The boundaries of any two elements in a MultiSurface
# may intersect, at most, at a finite number of Points.
#
# MultiSurface is a non-instantiable class in this International
# Standard. It defines a set of methods for its subclasses and is
# included for reasons of extensibility. The instantiable subclass of
# MultiSurface is MultiPolygon, corresponding to a collection of
# Polygons.
#
# == Notes
#
# MultiSurface is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::MultiSurface
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # The area of this MultiSurface, as measured in the spatial reference
  # system of this MultiSurface.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  def area; end

  # === SFS 1.1 Description
  #
  # The mathematical centroid for this MultiSurface as a Point. The
  # result is not guaranteed to be on this MultiSurface.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  def centroid; end

  # === SFS 1.1 Description
  #
  # A Point guaranteed to be on this MultiSurface.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  def point_on_surface; end
end

# == SFS 1.1 Description
#
# A Point is a 0-dimensional geometric object and represents a single
# location in coordinate space. A Point has an x-coordinate value and
# a y-coordinate value.
#
# The boundary of a Point is the empty set.
#
# == Notes
#
# Point is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# Some implementations may support higher dimensional points.
#
# Some libraries, such as GEOS, support "empty" points. Such objects
# might be returned as, for example, the centroid of an empty
# MultiPolygon. The SFS does not clearly define or even acknowledge
# the existence of such a type, so RGeo will currently generally
# replace them with empty GeometryCollection objects. Therefore,
# currently, every RGeo Point object represents an actual location
# with real coordinates.
module RGeo::Feature::Point
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  # Returns the m-coordinate for this Point as a floating-point
  # scalar value.
  #
  # This method may not be available if the point's factory does
  # not support M coordinates.
  #
  # @raise [Error::UnsupportedOperation]
  def m; end

  # === SFS 1.1 Description
  #
  # The x-coordinate value for this Point.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  def x; end

  # === SFS 1.1 Description
  #
  # The y-coordinate value for this Point.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  def y; end

  # Returns the z-coordinate for this Point as a floating-point
  # scalar value.
  #
  # This method may not be available if the point's factory does
  # not support Z coordinates.
  #
  # @raise [Error::UnsupportedOperation]
  def z; end
end

# == SFS 1.1 Description
#
# A Polygon is a planar Surface defined by 1 exterior boundary and 0 or
# more interior boundaries. Each interior boundary defines a hole in
# the Polygon.
#
# The assertions for Polygons (the rules that define valid Polygons)
# are as follows:
#
# (a) Polygons are topologically closed;
#
# (b) The boundary of a Polygon consists of a set of LinearRings that
# make up its exterior and interior boundaries;
#
# (c) No two Rings in the boundary cross and the Rings in the boundary
# of a Polygon may intersect at a Point but only as a tangent;
#
# (d) A Polygon may not have cut lines, spikes or punctures;
#
# (e) The interior of every Polygon is a connected point set;
#
# (f) The exterior of a Polygon with 1 or more holes is not connected.
# Each hole defines a connected component of the exterior.
#
# In the above assertions, interior, closure and exterior have the
# standard topological definitions. The combination of (a) and (c) make
# a Polygon a regular closed Point set.
#
# Polygons are simple geometric objects.
#
# == Notes
#
# Polygon is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
module RGeo::Feature::Polygon
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # Returns the exterior ring of this Polygon.
  #
  # === Notes
  #
  # Returns an object that supports the LinearRing interface.
  #
  # @raise [Error::UnsupportedOperation]
  def exterior_ring; end

  # === SFS 1.1 Description
  #
  # Returns the Nth interiorRing for this Polygon as a LineString.
  #
  # === Notes
  #
  # Returns an object that supports the LinearRing interface, or nil
  # if the given N is out of range. N is zero-based.
  # Does not support negative indexes.
  #
  # @raise [Error::UnsupportedOperation]
  def interior_ring_n(n); end

  # Returns the interior rings as a (possibly empty) array of objects
  # that support the LinearRing interface.
  #
  # @raise [Error::UnsupportedOperation]
  def interior_rings; end

  # === SFS 1.1 Description
  #
  # Returns the number of interiorRings in this Polygon.
  #
  # === Notes
  #
  # Returns an integer.
  #
  # @raise [Error::UnsupportedOperation]
  def num_interior_rings; end
end

# == SFS 1.1 Description
#
# A Surface is a 2-dimensional geometric object.
#
# A simple Surface consists of a single "patch" that is associated with
# one "exterior boundary" and 0 or more "interior" boundaries. Simple
# Surfaces in 3-dimensional space are isomorphic to planar Surfaces.
# Polyhedral Surfaces are formed by "stitching" together simple
# Surfaces along their boundaries, polyhedral Surfaces in 3-dimensional
# space may not be planar as a whole.
#
# The boundary of a simple Surface is the set of closed Curves
# corresponding to its "exterior" and "interior" boundaries.
#
# The only instantiable subclass of Surface defined in this
# specification, Polygon, is a simple Surface that is planar.
#
# == Notes
#
# Surface is defined as a module and is provided primarily
# for the sake of documentation. Implementations need not necessarily
# include this module itself. Therefore, you should not depend on the
# kind_of? method to check type. Instead, use the provided check_type
# class method (or === operator) defined in the Type module.
#
# Some implementations may support higher dimensional points.
module RGeo::Feature::Surface
  include ::RGeo::Feature::Geometry
  extend ::RGeo::Feature::Type

  # === SFS 1.1 Description
  #
  # The area of this Surface, as measured in the spatial reference
  # system of this Surface.
  #
  # === Notes
  #
  # Returns a floating-point scalar value.
  #
  # @raise [Error::UnsupportedOperation]
  def area; end

  # === SFS 1.1 Description
  #
  # The mathematical centroid for this Surface as a Point. The result
  # is not guaranteed to be on this Surface.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  def centroid; end

  # === SFS 1.1 Description
  #
  # A Point guaranteed to be on this Surface.
  #
  # === Notes
  #
  # Returns an object that supports the Point interface.
  #
  # @raise [Error::UnsupportedOperation]
  def point_on_surface; end
end

# This module provides the API for geometry type objects. Technically
# these objects are modules (such as RGeo::Feature::Point), but as
# objects they respond to the methods documented here.
#
# For example, you may determine whether a feature object is a
# point by calling:
#
#   RGeo::Feature::Point.check_type(object)
#
# A corresponding === operator is provided so you can use the type
# modules in a case-when clause:
#
#   case object
#   when RGeo::Feature::Point
#     # do stuff here...
#
# However, a feature object may not actually include the point module
# itself; hence, the following will *not* work:
#
#   object.is_a?(RGeo::Feature::Point)  # DON'T DO THIS-- DOES NOT WORK
#
# You may obtain the type of a feature object by calling its
# geometry_type method. You may then use the methods in this module to
# interrogate that type.
#
#   # supppose object is a Point
#   type = object.geometry_type  # RGeo::Feature::Point
#   type.type_name               # "Point"
#   type.supertype               # RGeo::Feature::Geometry
#
# You may also use the presence of this module to determine whether
# a particular object is a feature type:
#
#   RGeo::Feature::Type === object.geometry_type  # true
module RGeo::Feature::Type
  # Returns true if the given object is this type or a subtype
  # thereof, or if it is a feature object whose geometry_type is
  # this type or a subtype thereof.
  #
  # Note that feature objects need not actually include this module.
  # Therefore, the is_a? method will generally not work.
  def ===(rhs); end

  def add_subtype(type); end

  # Returns true if the given object is this type or a subtype
  # thereof, or if it is a feature object whose geometry_type is
  # this type or a subtype thereof.
  #
  # Note that feature objects need not actually include this module.
  # Therefore, the is_a? method will generally not work.
  def check_type(rhs); end

  # Iterates over the known immediate subtypes of this type.
  def each_immediate_subtype(&block); end

  # Returns true if this type is the same type or a subtype of the
  # given type.
  #
  # @return [Boolean]
  def subtype_of?(type); end

  # Returns the supertype of this type. The supertype of Geometry
  # is nil.
  def supertype; end

  # Returns the OpenGIS type name of this type. For example:
  #
  #   RGeo::Feature::Point.type_name  # "Point"
  def to_s; end

  # Returns the OpenGIS type name of this type. For example:
  #
  #   RGeo::Feature::Point.type_name  # "Point"
  def type_name; end

  class << self
    def extended(type); end
  end
end

module RGeo::Geographic
  class << self
    # Creates and returns a geographic factory that includes a
    # projection specified by a Proj4 coordinate system. Like all
    # geographic factories, this one creates features using latitude-
    # longitude values. However, calculations such as intersections are
    # done in the projected coordinate system, and size and distance
    # calculations report results in the projected units. Thus, this
    # factory actually includes two factories representing different
    # coordinate systems: the main factory representing the geographic
    # lat-long coordinate system, and an auxiliary "projection factory"
    # representing the projected coordinate system.
    #
    # This implementation is intended for advanced GIS applications
    # requiring greater control over the projection being used.
    #
    # === Options
    #
    # When creating a projected implementation, you must provide enough
    # information to construct a Proj4 specification for the projection.
    # Generally, this means you will provide either the projection's
    # factory itself (via the <tt>:projection_factory</tt> option), in
    # which case the factory must include a Proj4 coordinate system;
    # or, alternatively, you should provide the Proj4 coordinate system
    # and let this method construct a projection factory for you (which
    # it will do using the preferred Cartesian factory generator).
    # If you choose this second method, you may provide the proj4
    # directly via the <tt>:projection_proj4</tt> option, or indirectly
    # by providing both an <tt>:srid</tt> and a <tt>:srs_database</tt>
    # to use to look up the coordinate system.
    #
    # Following are detailed descriptions of the various options you can
    # pass to this method.
    #
    # [<tt>:projection_factory</tt>]
    #   Specify an existing Cartesian factory to use for the projection.
    #   This factory must have a non-nil Proj4. If this is provided, any
    #   <tt>:projection_proj4</tt>, <tt>:projection_coord_sys</tt>, and
    #   <tt>:projection_srid</tt> are ignored.
    # [<tt>:projection_proj4</tt>]
    #   Specify a Proj4 projection to use to construct the projection
    #   factory. This may be specified as a CoordSys::Proj4 object, or
    #   as a Proj4 string or hash representation.
    # [<tt>:projection_coord_sys</tt>]
    #   Specify a OGC coordinate system for the projection. This may be
    #   specified as an RGeo::CoordSys::CS::GeographicCoordinateSystem
    #   object, or as a String in OGC WKT format. Optional.
    # [<tt>:projection_srid</tt>]
    #   The SRID value to use for the projection factory. Defaults to
    #   the given projection coordinate system's authority code, or to
    #   0 if no projection coordinate system is known.
    # [<tt>:proj4</tt>]
    #   A proj4 projection for the geographic (lat-lon) factory. You may
    #   pass either an RGeo::CoordSys::Proj4 object, or a string or hash
    #   containing the Proj4 parameters. This coordinate system must be
    #   a geographic (lat/long) coordinate system. It defaults to the
    #   geographic part of the projection factory's coordinate system.
    #   Generally, you should leave it at the default unless you want
    #   the geographic coordinate system to be based on a different
    #   horizontal datum than the projection.
    # [<tt>:coord_sys</tt>]
    #   An OGC coordinate system for the geographic (lat-lon) factory,
    #   which may be an RGeo::CoordSys::CS::GeographicCoordinateSystem
    #   object or a string in OGC WKT format. It defaults to the
    #   geographic system embedded in the projection coordinate system.
    #   Generally, you should leave it at the default unless you want
    #   the geographic coordinate system to be based on a different
    #   horizontal datum than the projection.
    # [<tt>:srid</tt>]
    #   The SRID value to use for the main geographic factory. Defaults
    #   to the given geographic coordinate system's authority code, or
    #   to 0 if no geographic coordinate system is known.
    # [<tt>:srs_database</tt>]
    #   Optional. If provided, the object should respond to #get and
    #   #clear_cache. If both this and an SRID are
    #   provided, they are used to look up the proj4 and coord_sys
    #   objects from a spatial reference system database.
    # [<tt>:has_z_coordinate</tt>]
    #   Support a Z coordinate. Default is false.
    #   Note: this is ignored if a <tt>:projection_factory</tt> is
    #   provided; in that case, the geographic factory's z-coordinate
    #   availability will match the projection factory's setting.
    # [<tt>:has_m_coordinate</tt>]
    #   Support an M coordinate. Default is false.
    #   Note: this is ignored if a <tt>:projection_factory</tt> is
    #   provided; in that case, the geographic factory's m-coordinate
    #   availability will match the projection factory's setting.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKTParser.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. The value is a hash of
    #   configuration parameters for WKRep::WKBParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKBParser.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is <tt>{:convert_case => :upper}</tt>.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is the empty hash, indicating the default configuration
    #   for WKRep::WKBGenerator.
    #
    # If a <tt>:projection_factory</tt> is _not_ provided, you may also
    # provide options for configuring the projected Cartesian factory.
    # For example, if GEOS is used for the projected factory, you may
    # also set the <tt>:lenient_multi_polygon_assertions</tt> and
    # <tt>:buffer_resolution</tt> options. See RGeo::Geos.factory for
    # more details.
    def projected_factory(opts = T.unsafe(nil)); end

    # Creates and returns a geographic factory that is designed for
    # visualization applications that use Google or Bing maps, or any
    # other visualization systems that use the same projection. It
    # includes a projection factory that matches the projection used
    # by those mapping systems.
    #
    # Like all geographic factories, this one creates features using
    # latitude-longitude values. However, calculations such as
    # intersections are done in the projected coordinate system, and
    # size and distance calculations report results in the projected
    # units.
    #
    # The behavior of the simple_mercator factory could also be obtained
    # using a projected_factory with appropriate Proj4 specifications.
    # However, the simple_mercator implementation is done without
    # actually requiring the Proj4 library. The projections are simple
    # enough to be implemented in pure ruby.
    #
    # === About the coordinate system
    #
    # Many popular visualization technologies, such as Google and Bing
    # maps, actually use two coordinate systems. The first is the
    # standard WSG84 lat-long system used by the GPS and represented
    # by EPSG 4326. Most API calls and input-output in these mapping
    # technologies utilize this coordinate system. The second is a
    # Mercator projection based on a "sphericalization" of the WGS84
    # lat-long system. This projection is the basis of the map's screen
    # and tiling coordinates, and has been assigned EPSG 3857.
    #
    # This factory represents both coordinate systems. The main factory
    # produces data in the lat-long system and reports SRID 4326, and
    # the projected factory produces data in the projection and reports
    # SRID 3857. Latitudes are restricted to the range
    # (-85.05112877980659, 85.05112877980659), which conveniently
    # results in a square projected domain.
    #
    # === Options
    #
    # You may use the following options when creating a simple_mercator
    # factory:
    #
    # [<tt>:has_z_coordinate</tt>]
    #   Support a Z coordinate. Default is false.
    # [<tt>:has_m_coordinate</tt>]
    #   Support an M coordinate. Default is false.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKTParser.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. The value is a hash of
    #   configuration parameters for WKRep::WKBParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKBParser.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is <tt>{:convert_case => :upper}</tt>.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is the empty hash, indicating the default configuration
    #   for WKRep::WKBGenerator.
    #
    # You may also provide options understood by the underlying
    # projected Cartesian factory. For example, if GEOS is used for the
    # projected factory, you may also set the
    # <tt>:lenient_multi_polygon_assertions</tt> and
    # <tt>:buffer_resolution</tt> options. See RGeo::Geos.factory for
    # more details.
    def simple_mercator_factory(opts = T.unsafe(nil)); end

    # Creates and returns a geographic factory that does not include a
    # a projection, and which performs calculations assuming a
    # spherical earth. In other words, geodesics are treated as great
    # circle arcs, and geometric calculations are handled accordingly.
    # Size and distance calculations report results in meters.
    # This implementation is thus ideal for everyday calculations on
    # the globe in which good accuracy is desired, but in which it is
    # not deemed necessary to perform the complex ellipsoidal
    # calculations needed for greater precision.
    #
    # The maximum error is about 0.5 percent, for objects and
    # calculations that span a significant percentage of the globe, due
    # to distortion caused by rotational flattening of the earth. For
    # calculations that span a much smaller area, the error can drop to
    # a few meters or less.
    #
    # === Limitations
    #
    # This implementation does not implement some of the more advanced
    # geometric operations. In particular:
    #
    # * Relational operators such as Feature::Geometry#intersects? are
    #   not implemented for most types.
    # * Relational constructors such as Feature::Geometry#union are
    #   not implemented for most types.
    # * Buffer, convex hull, and envelope calculations are not
    #   implemented for most types. Boundaries are available except for
    #   GeometryCollection.
    # * Length calculations are available, but areas are not. Distances
    #   are available only between points.
    # * Equality and simplicity evaluation are implemented for some but
    #   not all types.
    # * Assertions for polygons and multipolygons are not implemented.
    #
    # Unimplemented operations will return nil if invoked.
    #
    # === Options
    #
    # You may use the following options when creating a spherical
    # factory:
    #
    # [<tt>:has_z_coordinate</tt>]
    #   Support a Z coordinate. Default is false.
    # [<tt>:has_m_coordinate</tt>]
    #   Support an M coordinate. Default is false.
    # [<tt>:uses_lenient_assertions</tt>]
    #   If set to true, assertion checking is disabled. This includes
    #   simplicity checking on LinearRing, and validity checks on
    #   Polygon and MultiPolygon. This may speed up creation of certain
    #   objects, at the expense of not doing the proper checking for
    #   OGC compliance. Default is false.
    # [<tt>:buffer_resolution</tt>]
    #   The resolution of buffers around geometries created by this
    #   factory. This controls the number of line segments used to
    #   approximate curves. The default is 1, which causes, for
    #   example, the buffer around a point to be approximated by a
    #   4-sided polygon. A resolution of 2 would cause that buffer
    #   to be approximated by an 8-sided polygon. The exact behavior
    #   for different kinds of buffers is not specified precisely,
    #   but in general the value is taken as the number of segments
    #   per 90-degree curve.
    # [<tt>:proj4</tt>]
    #   Provide the coordinate system in Proj4 format. You may pass
    #   either an RGeo::CoordSys::Proj4 object, or a string or hash
    #   containing the Proj4 parameters. This coordinate system must be
    #   a geographic (lat/long) coordinate system. The default is the
    #   "popular visualization CRS" (EPSG 4055), represented by
    #   "<tt>+proj=longlat +a=6378137 +b=6378137 +towgs84=0,0,0,0,0,0,0 +no_defs</tt>".
    #   Has no effect if Proj4 is not available.
    # [<tt>:coord_sys</tt>]
    #   Provide a coordinate system in OGC format, either as an object
    #   (one of the CoordSys::CS classes) or as a string in WKT format.
    #   This coordinate system must be a GeographicCoordinateSystem.
    #   The default is the "popular visualization CRS" (EPSG 4055).
    # [<tt>:srid</tt>]
    #   The SRID that should be returned by features from this factory.
    #   Default is 4055, indicating EPSG 4055, the "popular
    #   visualization crs". You may alternatively wish to set the srid
    #   to 4326, indicating the WGS84 crs, but note that that value
    #   implies an ellipsoidal datum, not a spherical datum.
    # [<tt>:srs_database</tt>]
    #   Optional. If provided, the object should respond to #get and
    #   #clear_cache. If both this and an SRID are
    #   provided, they are used to look up the proj4 and coord_sys
    #   objects from a spatial reference system database.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKTParser.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. The value is a hash of
    #   configuration parameters for WKRep::WKBParser.new. Default is
    #   the empty hash, indicating the default configuration for
    #   WKRep::WKBParser.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is <tt>{:convert_case => :upper}</tt>.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKT. The value is a hash of
    #   configuration parameters for WKRep::WKTGenerator.new.
    #   Default is the empty hash, indicating the default configuration
    #   for WKRep::WKBGenerator.
    def spherical_factory(opts = T.unsafe(nil)); end

    private

    def coord_sys_4055; end
    def coord_sys_4326; end
    def proj_4055; end
    def proj_4326; end
  end
end

# This class implements the various factories for geography features.
# See methods of the RGeo::Geographic module for the API for creating
# geography factories.
class RGeo::Geographic::Factory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  # @return [Factory] a new instance of Factory
  def initialize(impl_prefix, opts = T.unsafe(nil)); end

  # Equivalence test.
  #
  # @return [Boolean]
  def ==(rhs_); end

  # See RGeo::Feature::Factory#collection
  def collection(elems); end

  # See RGeo::Feature::Factory#coord_sys
  def coord_sys; end

  # Psych support
  def encode_with(coder); end

  # Equivalence test.
  #
  # @return [Boolean]
  def eql?(rhs_); end

  def generate_wkb(obj); end
  def generate_wkt(obj); end

  # Returns true if this factory supports a projection.
  #
  # @return [Boolean]
  def has_projection?; end

  # Standard hash code
  def hash; end

  def init_with(coder); end

  # See RGeo::Feature::Factory#line
  def line(start, stop); end

  # See RGeo::Feature::Factory#line_string
  def line_string(points); end

  # See RGeo::Feature::Factory#linear_ring
  def linear_ring(points); end

  # Marshal support
  def marshal_dump; end

  def marshal_load(data_); end
  def marshal_wkb_generator; end
  def marshal_wkb_parser; end

  # See RGeo::Feature::Factory#multi_line_string
  def multi_line_string(elems); end

  # See RGeo::Feature::Factory#multi_point
  def multi_point(elems); end

  # See RGeo::Feature::Factory#multi_polygon
  def multi_polygon(elems); end

  # See RGeo::Feature::Factory#parse_wkb
  def parse_wkb(str); end

  # See RGeo::Feature::Factory#parse_wkt
  def parse_wkt(str); end

  # See RGeo::Feature::Factory#point
  def point(x, y, *extra); end

  # See RGeo::Feature::Factory#polygon
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#proj4
  def proj4; end

  # Projects the given geometry into the projected coordinate space,
  # and returns the projected geometry.
  # Returns nil if this factory does not support a projection.
  # Raises Error::InvalidGeometry if the given geometry is not of
  # this factory.
  def project(geometry); end

  # Returns the factory for the projected coordinate space,
  # or nil if this factory does not support a projection.
  def projection_factory; end

  # Returns a ProjectedWindow specifying the limits of the domain of
  # the projection space.
  # Returns nil if this factory does not support a projection, or the
  # projection limits are not known.
  def projection_limits_window; end

  # Returns true if this factory supports a projection and the
  # projection wraps its x (easting) direction. For example, a
  # Mercator projection wraps, but a local projection that is valid
  # only for a small area does not wrap. Returns nil if this factory
  # does not support or a projection, or if it is not known whether
  # or not it wraps.
  #
  # @return [Boolean]
  def projection_wraps?; end

  # Sets the attribute projector
  #
  # @param value the value to set the attribute projector to.
  def projector=(_arg0); end

  # See RGeo::Feature::Factory#property
  def property(name); end

  def psych_wkt_generator; end
  def psych_wkt_parser; end

  # Returns the srid reported by this factory.
  def srid; end

  # Reverse-projects the given geometry from the projected coordinate
  # space into lat-long space.
  # Raises Error::InvalidGeometry if the given geometry is not of
  # the projection defined by this factory.
  def unproject(geometry); end
end

class RGeo::Geographic::Proj4Projector
  # @return [Proj4Projector] a new instance of Proj4Projector
  def initialize(geography_factory, projection_factory); end

  def limits_window; end
  def project(geometry); end

  # Returns the value of attribute projection_factory.
  def projection_factory; end

  def set_factories(geography_factory, projection_factory); end
  def unproject(geometry); end

  # @return [Boolean]
  def wraps?; end

  class << self
    def create_from_existing_factory(geography_factory, projection_factory); end
    def create_from_proj4(geography_factory, proj4, opts = T.unsafe(nil)); end
  end
end

class RGeo::Geographic::ProjectedGeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::ProjectedGeometryMethods
  def boundary; end
  def buffer(distance); end
  def buffer_with_style(distance, end_cap_style, join_style, mitre_limit); end

  # @return [Boolean]
  def contains?(rhs); end

  def convex_hull; end

  # @return [Boolean]
  def crosses?(rhs); end

  def difference(rhs); end

  # @return [Boolean]
  def disjoint?(rhs); end

  def distance(rhs); end

  # @return [Boolean]
  def empty?; end

  def envelope; end

  # @return [Boolean]
  def equals?(rhs); end

  def intersection(rhs); end

  # @return [Boolean]
  def intersects?(rhs); end

  # @return [Boolean]
  def is_empty?; end

  # @return [Boolean]
  def is_simple?; end

  # @return [Boolean]
  def overlaps?(rhs); end

  def point_on_surface; end
  def projection; end
  def relate(rhs, pattern_); end

  # @return [Boolean]
  def simple?; end

  def simplify(tolerance); end
  def simplify_preserve_topology(tolerance); end
  def srid; end
  def sym_difference(rhs); end

  # @return [Boolean]
  def touches?(rhs); end

  def union(rhs); end

  # @return [Boolean]
  def within?(rhs); end
end

class RGeo::Geographic::ProjectedLineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geographic::ProjectedLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::ProjectedLineStringMethods
  private

  def validate_geometry; end
end

class RGeo::Geographic::ProjectedLinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::Geographic::ProjectedLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geographic::ProjectedMultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNCurveMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geographic::ProjectedMultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geographic::ProjectedMultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNSurfaceMethods
  include ::RGeo::Geographic::ProjectedMultiPolygonMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::ProjectedMultiPolygonMethods
  private

  def validate_geometry; end
end

module RGeo::Geographic::ProjectedNCurveMethods
  def length; end
end

module RGeo::Geographic::ProjectedNSurfaceMethods
  def area; end
  def centroid; end
end

class RGeo::Geographic::ProjectedPointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedPointMethods
  include ::RGeo::ActiveRecord::GeometryMixin

  def lat; end
  def latitude; end
  def lon; end
  def longitude; end
end

module RGeo::Geographic::ProjectedPointMethods
  def canonical_lon; end
  def canonical_longitude; end
  def canonical_point; end
  def canonical_x; end

  private

  def validate_geometry; end

  class << self
    # @private
    def included(klass); end
  end
end

class RGeo::Geographic::ProjectedPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::Geographic::ProjectedGeometryMethods
  include ::RGeo::Geographic::ProjectedNSurfaceMethods
  include ::RGeo::Geographic::ProjectedPolygonMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::ProjectedPolygonMethods
  private

  def validate_geometry; end
end

# This object represents an axis-aligned rectangle in a map projection
# coordinate system. It is commonly used to specify the viewport for a
# map visualization, an envelope in a projected coordinate system, or
# a spatial constraint. It must be attached to a Geographic::Factory
# that has a projection.
class RGeo::Geographic::ProjectedWindow
  # Create a new ProjectedWindow given the Geographic::Factory, and the
  # x and y extents of the rectangle.
  #
  # The window will be intelligently clamped to the limits imposed by
  # the factory. For example, the simple mercator factory limits
  # latitude to approximately +/-85 degrees.
  #
  # Generally, you will not need to call this low-level constructor
  # directly. Instead, use one of the provided class methods.
  #
  # @return [ProjectedWindow] a new instance of ProjectedWindow
  def initialize(factory_, x_min_, y_min_, x_max_, y_max_, opts_ = T.unsafe(nil)); end

  # Returns a new window resulting from scaling this window by the
  # given factors, which must be floating-point values.
  # If y_factor is not explicitly given, it defaults to the same as
  # the x_factor.
  def *(x_factor_, y_factor_ = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(obj_); end

  # Returns the center of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  def center_point; end

  # Returns a two-element array containing the x and y coordinates
  # of the center of the rectangle.
  def center_xy; end

  # Returns a new window resulting from clamping this window to the
  # given minimum and maximum widths and heights, in the projected
  # coordinate system. The center of the resulting window is the
  # same as the center of this window. Any of the arguments may be
  # given as nil, indicating no constraint.
  def clamped_by(min_width_, min_height_, max_width_, max_height_); end

  # Returns true if the rectangle contains the given point, which
  # must be a Feature::Point in _unprojected_ (lat/lng) space.
  #
  # @return [Boolean]
  def contains_point?(point_); end

  # Returns true if the given window is completely contained within
  # this window.
  #
  # @return [Boolean]
  def contains_window?(window_); end

  # Returns true if the projection wraps along the x axis, and this
  # rectangle crosses that seam.
  #
  # @return [Boolean]
  def crosses_seam?; end

  # Returns true if the rectangle has zero area.
  #
  # @return [Boolean]
  def degenerate?; end

  # @return [Boolean]
  def eql?(obj_); end

  # Returns the Geographic::Factory associated with this window.
  # Note that this factory is the overall geography factory, not the
  # projected factory (which can be obtained by calling
  # Geographic::Factory#projection_factory on this factory).
  def factory; end

  def hash; end

  # Returns the height of the rectangle.
  def height; end

  def inspect; end

  # Returns the northeast corner of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  def ne_point; end

  # Returns the northwest corner of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  def nw_point; end

  # Returns a random point inside the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  def random_point; end

  # Returns a new window resulting from scaling this window by the
  # given factors, which must be floating-point values.
  # If y_factor is not explicitly given, it defaults to the same as
  # the x_factor.
  def scaled_by(x_factor_, y_factor_ = T.unsafe(nil)); end

  # Returns the southeast corner of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  def se_point; end

  # Returns the southwest corner of the rectangle in _unprojected_
  # (lat/lng) space, as a Feature::Point object.
  def sw_point; end

  def to_s; end

  # Returns the width of the rectangle.
  def width; end

  # Returns a new window resulting from adding the given margin to
  # this window. If y_margin is not given, it defaults to the same
  # value as x_margin. Note that the margins may be negative to
  # indicate shrinking of the window.
  def with_margin(x_margin_, y_margin_ = T.unsafe(nil)); end

  # Returns the upper limit in the x (easting) direction.
  def x_max; end

  # Returns the lower limit in the x (easting) direction.
  def x_min; end

  # Returns the width of the rectangle.
  def x_span; end

  # Returns the upper limit in the y (northing) direction.
  def y_max; end

  # Returns the lower limit in the y (northing) direction.
  def y_min; end

  # Returns the height of the rectangle.
  def y_span; end

  class << self
    # Creates a new window that contains all of the given points.
    # which must be Feature::Point objects in unprojected (lat/lng)
    # space.
    def bounding_points(points_); end

    # Creates a new window whose coordinates are the given points,
    # which must be Feature::Point objects in unprojected (lat/lng)
    # space.
    def for_corners(sw_, ne_); end

    # Creates a new window that surrounds the given point with the
    # given margin. The point must be a Feature::Point object in
    # unprojected (lat/lng) space, while the margins are numbers in
    # projected space. The y_margin may be given as nil, in which
    # case it is set to the same as the x_margin.
    def surrounding_point(point_, x_margin_ = T.unsafe(nil), y_margin_ = T.unsafe(nil)); end
  end
end

class RGeo::Geographic::SimpleMercatorProjector
  # @return [SimpleMercatorProjector] a new instance of SimpleMercatorProjector
  def initialize(geography_factory, opts = T.unsafe(nil)); end

  def limits_window; end
  def project(geometry); end

  # Returns the value of attribute projection_factory.
  def projection_factory; end

  def set_factories(geography_factory, projection_factory); end
  def unproject(geometry); end

  # @return [Boolean]
  def wraps?; end

  class << self
    def _coordsys_3857; end
    def _proj4_3857; end
  end
end

RGeo::Geographic::SimpleMercatorProjector::EQUATORIAL_RADIUS = T.let(T.unsafe(nil), Float)

class RGeo::Geographic::SphericalGeometryCollectionImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::SphericalGeometryMethods
  def srid; end
end

class RGeo::Geographic::SphericalLineImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Line
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLineMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geographic::SphericalLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::SphericalLineStringMethods
  def arcs; end

  # @return [Boolean]
  def is_simple?; end

  def length; end

  # @return [Boolean]
  def simple?; end
end

class RGeo::Geographic::SphericalLinearRingImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Curve
  include ::RGeo::Feature::LineString
  include ::RGeo::Feature::LinearRing
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicLineStringMethods
  include ::RGeo::ImplHelper::BasicLinearRingMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::SphericalMath; end

# Represents a finite arc on the sphere.
class RGeo::Geographic::SphericalMath::ArcXYZ
  # @return [ArcXYZ] a new instance of ArcXYZ
  def initialize(start, stop); end

  # @return [Boolean]
  def ==(rhs); end

  def axis; end

  # @return [Boolean]
  def contains_point?(obj); end

  # @return [Boolean]
  def degenerate?; end

  # Returns the value of attribute e.
  def e; end

  # @return [Boolean]
  def eql?(rhs); end

  # @return [Boolean]
  def intersects_arc?(obj); end

  def length; end

  # Returns the value of attribute s.
  def s; end

  def to_s; end
end

# Represents a point on the unit sphere in (x,y,z) coordinates
# instead of lat-lon. This form is often faster, more convenient,
# and more numerically stable for certain computations.
#
# The coordinate system is a right-handed system where the z-axis
# goes through the north pole, the x-axis goes through the prime
# meridian, and the y-axis goes through +90 degrees longitude.
#
# This object is also used to represent a great circle, as its axis
# of rotation.
class RGeo::Geographic::SphericalMath::PointXYZ
  # @return [PointXYZ] a new instance of PointXYZ
  def initialize(x, y, z); end

  def %(rhs); end
  def *(rhs); end

  # @return [Boolean]
  def ==(rhs); end

  # Creates some point that is perpendicular to this point
  def create_perpendicular; end

  def dist_to_point(rhs); end

  # @return [Boolean]
  def eql?(rhs); end

  def latlon; end
  def lonlat; end
  def to_s; end

  # Returns the value of attribute x.
  def x; end

  # Returns the value of attribute y.
  def y; end

  # Returns the value of attribute z.
  def z; end

  class << self
    def from_latlon(lat, lon); end
    def weighted_combination(p1, w1, p2, w2); end
  end
end

RGeo::Geographic::SphericalMath::PointXYZ::P1 = T.let(T.unsafe(nil), RGeo::Geographic::SphericalMath::PointXYZ)
RGeo::Geographic::SphericalMath::PointXYZ::P2 = T.let(T.unsafe(nil), RGeo::Geographic::SphericalMath::PointXYZ)
RGeo::Geographic::SphericalMath::RADIUS = T.let(T.unsafe(nil), Float)

class RGeo::Geographic::SphericalMultiLineStringImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiCurve
  include ::RGeo::Feature::MultiLineString
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiLineStringMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalMultiLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::SphericalMultiLineStringMethods
  def length; end
end

class RGeo::Geographic::SphericalMultiPointImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiPoint
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPointMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geographic::SphericalMultiPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::Enumerable
  include ::RGeo::Feature::GeometryCollection
  include ::RGeo::Feature::MultiSurface
  include ::RGeo::Feature::MultiPolygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::RGeo::ImplHelper::BasicMultiPolygonMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geographic::SphericalPointImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Point
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPointMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalPointMethods
  include ::RGeo::ActiveRecord::GeometryMixin

  def lat; end
  def latitude; end
  def lon; end
  def longitude; end
end

module RGeo::Geographic::SphericalPointMethods
  def buffer(distance); end
  def distance(rhs); end

  # @return [Boolean]
  def equals?(rhs); end

  def xyz; end

  private

  def validate_geometry; end

  class << self
    # @private
    def included(klass); end
  end
end

class RGeo::Geographic::SphericalPolygonImpl
  include ::RGeo::Feature::Geometry
  include ::RGeo::Feature::Surface
  include ::RGeo::Feature::Polygon
  include ::RGeo::Feature::Instance
  include ::RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::ImplHelper::BasicPolygonMethods
  include ::RGeo::Geographic::SphericalGeometryMethods
  include ::RGeo::Geographic::SphericalPolygonMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geographic::SphericalPolygonMethods
  def centroid; end
end

module RGeo::Geos
  class << self
    # Returns true if the given feature is a CAPI GEOS feature, or if
    # the given factory is a CAPI GEOS factory.
    #
    # @return [Boolean]
    def capi_geos?(object); end

    # Returns true if the CAPI GEOS implementation is supported.
    #
    # @return [Boolean]
    def capi_supported?; end

    # Returns a factory for the GEOS implementation.
    # Returns nil if the GEOS implementation is not supported.
    #
    # Note that GEOS does not natively support 4-dimensional data
    # (i.e. both z and m values). However, RGeo's GEOS wrapper does
    # provide a 4-dimensional factory that utilizes an extra native
    # GEOS object to handle the extra coordinate. Hence, a factory
    # configured with both Z and M support will work, but will be
    # slower than a 2-dimensional or 3-dimensional factory.
    #
    # Options include:
    #
    # [<tt>:native_interface</tt>]
    #   Specifies which native interface to use. Possible values are
    #   <tt>:capi</tt> and <tt>:ffi</tt>. The default is the value
    #   of the preferred_native_interface.
    # [<tt>:uses_lenient_multi_polygon_assertions</tt>]
    #   If set to true, assertion checking on MultiPolygon is disabled.
    #   This may speed up creation of MultiPolygon objects, at the
    #   expense of not doing the proper checking for OGC MultiPolygon
    #   compliance. See RGeo::Feature::MultiPolygon for details on
    #   the MultiPolygon assertions. Default is false. Also called
    #   <tt>:lenient_multi_polygon_assertions</tt>.
    # [<tt>:buffer_resolution</tt>]
    #   The resolution of buffers around geometries created by this
    #   factory. This controls the number of line segments used to
    #   approximate curves. The default is 1, which causes, for
    #   example, the buffer around a point to be approximated by a
    #   4-sided polygon. A resolution of 2 would cause that buffer
    #   to be approximated by an 8-sided polygon. The exact behavior
    #   for different kinds of buffers is defined by GEOS.
    # [<tt>:srid</tt>]
    #   Set the SRID returned by geometries created by this factory.
    #   Default is 0.
    # [<tt>:proj4</tt>]
    #   The coordinate system in Proj4 format, either as a
    #   CoordSys::Proj4 object or as a string or hash representing the
    #   proj4 format. Optional.
    # [<tt>:coord_sys</tt>]
    #   The coordinate system in OGC form, either as a subclass of
    #   CoordSys::CS::CoordinateSystem, or as a string in WKT format.
    #   Optional.
    # [<tt>:srs_database</tt>]
    #   Optional. If provided, the object should respond to #get and
    #   #clear_cache. If both this and an SRID are
    #   provided, they are used to look up the proj4 and coord_sys
    #   objects from a spatial reference system database.
    # [<tt>:has_z_coordinate</tt>]
    #   Support <tt>z_coordinate</tt>. Default is false.
    # [<tt>:has_m_coordinate</tt>]
    #   Support <tt>m_coordinate</tt>. Default is false.
    # [<tt>:wkt_parser</tt>]
    #   Configure the parser for WKT. You may either pass a hash of
    #   configuration parameters for WKRep::WKTParser.new, or the
    #   special value <tt>:geos</tt>, indicating to use the native
    #   GEOS parser. Default is the empty hash, indicating the default
    #   configuration for WKRep::WKTParser.
    #   Note that the special <tt>:geos</tt> value is not supported for
    #   ZM factories, since GEOS currently can't handle ZM natively.
    # [<tt>:wkb_parser</tt>]
    #   Configure the parser for WKB. You may either pass a hash of
    #   configuration parameters for WKRep::WKBParser.new, or the
    #   special value <tt>:geos</tt>, indicating to use the native
    #   GEOS parser. Default is the empty hash, indicating the default
    #   configuration for WKRep::WKBParser.
    #   Note that the special <tt>:geos</tt> value is not supported for
    #   ZM factories, since GEOS currently can't handle ZM natively.
    # [<tt>:wkt_generator</tt>]
    #   Configure the generator for WKT. You may either pass a hash of
    #   configuration parameters for WKRep::WKTGenerator.new, or the
    #   special value <tt>:geos</tt>, indicating to use the native
    #   GEOS generator. Default is <tt>{:convert_case => :upper}</tt>.
    #   Note that the special <tt>:geos</tt> value is not supported for
    #   ZM factories, since GEOS currently can't handle ZM natively.
    # [<tt>:wkb_generator</tt>]
    #   Configure the generator for WKB. You may either pass a hash of
    #   configuration parameters for WKRep::WKBGenerator.new, or the
    #   special value <tt>:geos</tt>, indicating to use the native
    #   GEOS generator. Default is the empty hash, indicating the
    #   default configuration for WKRep::WKBGenerator.
    #   Note that the special <tt>:geos</tt> value is not supported for
    #   ZM factories, since GEOS currently can't handle ZM natively.
    # [<tt>:auto_prepare</tt>]
    #   Request an auto-prepare strategy. Supported values are
    #   <tt>:simple</tt> and <tt>:disabled</tt>. The former (which is
    #   the default) generates a prepared geometry the second time an
    #   operation that would benefit from it is called. The latter
    #   never automatically generates a prepared geometry (unless you
    #   generate one explicitly using the <tt>prepare!</tt> method).
    def factory(opts = T.unsafe(nil)); end

    # Returns a Feature::FactoryGenerator that creates Geos-backed
    # factories. The given options are used as the default options.
    #
    # A common case for this is to provide the <tt>:srs_database</tt>
    # as a default. Then, the factory generator need only be passed
    # an SRID and it will automatically fetch the appropriate Proj4
    # and CoordSys objects.
    def factory_generator(defaults = T.unsafe(nil)); end

    # Returns true if the given feature is an FFI GEOS feature, or if
    # the given factory is an FFI GEOS factory.
    #
    # @return [Boolean]
    def ffi_geos?(object); end

    # Returns true if the FFI GEOS implementation is supported.
    #
    # @return [Boolean]
    def ffi_supported?; end

    # Returns true if the given feature is a GEOS feature, or if the given
    # factory is a GEOS factory. Does not distinguish between CAPI and FFI.
    #
    # @return [Boolean]
    def geos?(object); end

    # @return [Boolean]
    def is_capi_geos?(object); end

    # @return [Boolean]
    def is_ffi_geos?(object); end

    # @return [Boolean]
    def is_geos?(object); end

    # The preferred native interface. This is the native interface
    # used by default when a factory is created.
    # Supported values are <tt>:capi</tt> and <tt>:ffi</tt>.
    #
    # This is set automatically when RGeo loads, to <tt>:capi</tt>
    # if the CAPI interface is available, otheriwse to <tt>:ffi</tt>
    # if FFI is available, otherwise to nil if no GEOS interface is
    # available. You can override this setting if you want to prefer
    # FFI over CAPI.
    def preferred_native_interface; end

    # The preferred native interface. This is the native interface
    # used by default when a factory is created.
    # Supported values are <tt>:capi</tt> and <tt>:ffi</tt>.
    #
    # This is set automatically when RGeo loads, to <tt>:capi</tt>
    # if the CAPI interface is available, otheriwse to <tt>:ffi</tt>
    # if FFI is available, otherwise to nil if no GEOS interface is
    # available. You can override this setting if you want to prefer
    # FFI over CAPI.
    def preferred_native_interface=(_arg0); end

    # Returns true if any GEOS implementation is supported.
    # If this returns false, GEOS features are not available at all.
    #
    # @return [Boolean]
    def supported?; end

    # Returns the GEOS library version as a string of the format "x.y.z".
    # Returns nil if GEOS is not available.
    def version; end
  end
end

RGeo::Geos::CAP_FLAT = T.let(T.unsafe(nil), Integer)
RGeo::Geos::CAP_ROUND = T.let(T.unsafe(nil), Integer)
RGeo::Geos::CAP_SQUARE = T.let(T.unsafe(nil), Integer)

# This the FFI-GEOS implementation of RGeo::Feature::Factory.
class RGeo::Geos::FFIFactory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  # Create a new factory. Returns nil if the FFI-GEOS implementation
  # is not supported.
  #
  # See RGeo::Geos.factory for a list of supported options.
  #
  # @return [FFIFactory] a new instance of FFIFactory
  def initialize(opts = T.unsafe(nil)); end

  # Factory equivalence test.
  #
  # @return [Boolean]
  def ==(rhs); end

  def _auto_prepare; end
  def _has_3d; end

  # Returns the resolution used by buffer calculations on geometries
  # created by this factory
  def buffer_resolution; end

  # See RGeo::Feature::Factory#collection
  def collection(elems); end

  def convert_to_fg_geometry(obj, type = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#coord_sys
  def coord_sys; end

  # Psych support
  def encode_with(coder); end

  # Factory equivalence test.
  #
  # @return [Boolean]
  def eql?(rhs); end

  def generate_wkb(geom); end
  def generate_wkt(geom); end

  # Standard hash code
  def hash; end

  def init_with(coder); end

  # Standard object inspection output
  def inspect; end

  # Returns true if this factory is lenient with MultiPolygon assertions
  #
  # @return [Boolean]
  def lenient_multi_polygon_assertions?; end

  # See RGeo::Feature::Factory#line
  def line(start, stop); end

  # See RGeo::Feature::Factory#line_string
  #
  # @raise [Error::InvalidGeometry]
  def line_string(points); end

  # See RGeo::Feature::Factory#linear_ring
  def linear_ring(points); end

  # Marshal support
  def marshal_dump; end

  def marshal_load(data); end

  # See RGeo::Feature::Factory#multi_line_string
  def multi_line_string(elems); end

  # See RGeo::Feature::Factory#multi_point
  def multi_point(elems); end

  # See RGeo::Feature::Factory#multi_polygon
  def multi_polygon(elems); end

  # See RGeo::Feature::Factory#override_cast
  def override_cast(original, ntype, flags); end

  # See RGeo::Feature::Factory#parse_wkb
  def parse_wkb(str); end

  # See RGeo::Feature::Factory#parse_wkt
  def parse_wkt(str); end

  # See RGeo::Feature::Factory#point
  def point(x, y, z = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#polygon
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#proj4
  def proj4; end

  # See RGeo::Feature::Factory#property
  def property(name_); end

  def read_for_marshal(str); end
  def read_for_psych(str); end

  # Returns the SRID of geometries created by this factory.
  def srid; end

  # Create a feature that wraps the given ffi-geos geometry object
  def wrap_fg_geom(fg_geom, klass = T.unsafe(nil)); end

  def write_for_marshal(geom); end
  def write_for_psych(geom); end

  private

  def create_fg_linear_ring(points); end
end

class RGeo::Geos::FFIGeometryCollectionImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::FFIGeometryCollectionMethods
end

module RGeo::Geos::FFIGeometryCollectionMethods
  include ::Enumerable

  def [](n); end
  def each; end
  def geometry_n(n); end
  def geometry_type; end
  def hash; end
  def num_geometries; end

  # @return [Boolean]
  def rep_equals?(rhs); end

  def size; end
end

class RGeo::Geos::FFIGeometryImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
end

module RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Feature::Instance

  def initialize(factory, fg_geom, klasses); end

  def *(rhs); end
  def +(rhs); end
  def -(rhs); end

  # @return [Boolean]
  def ==(rhs); end

  def _klasses; end
  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(distance); end

  # @return [Boolean]
  def contains?(rhs); end

  def convex_hull; end

  # @return [Boolean]
  def crosses?(rhs); end

  def detach_fg_geom; end
  def difference(rhs); end
  def dimension; end

  # @return [Boolean]
  def disjoint?(rhs); end

  def distance(rhs); end

  # @return [Boolean]
  def empty?; end

  # Psych support
  def encode_with(coder); end

  def envelope; end

  # @return [Boolean]
  def eql?(rhs); end

  # @return [Boolean]
  def equals?(rhs); end

  # Returns the value of attribute factory.
  def factory; end

  # Returns the value of attribute fg_geom.
  def fg_geom; end

  def geometry_type; end
  def init_with(coder); end
  def inspect; end
  def intersection(rhs); end

  # @return [Boolean]
  def intersects?(rhs); end

  # @return [Boolean]
  def is_empty?; end

  # @return [Boolean]
  def is_simple?; end

  # Marshal support
  def marshal_dump; end

  def marshal_load(data); end

  # @return [Boolean]
  def overlaps?(rhs); end

  def point_on_surface; end
  def prepare!; end

  # @return [Boolean]
  def prepared?; end

  # DEPRECATED
  #
  # @return [Boolean]
  def relate(rhs, pattern); end

  # @return [Boolean]
  def relate?(rhs, pattern); end

  # @return [Boolean]
  def simple?; end

  def srid; end
  def sym_difference(rhs); end
  def to_s; end

  # @return [Boolean]
  def touches?(rhs); end

  def unary_union; end
  def union(rhs); end

  # @return [Boolean]
  def within?(rhs); end

  private

  def initialize_copy(orig); end
  def request_prepared; end
end

class RGeo::Geos::FFILineImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFILineStringMethods
  include ::RGeo::Geos::FFILineMethods
end

module RGeo::Geos::FFILineMethods
  def geometry_type; end
end

class RGeo::Geos::FFILineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFILineStringMethods
end

module RGeo::Geos::FFILineStringMethods
  # @return [Boolean]
  def closed?; end

  def coordinates; end
  def end_point; end
  def geometry_type; end
  def hash; end

  # @return [Boolean]
  def is_closed?; end

  # @return [Boolean]
  def is_ring?; end

  def length; end
  def num_points; end
  def point_n(n); end
  def points; end

  # @return [Boolean]
  def rep_equals?(rhs); end

  # @return [Boolean]
  def ring?; end

  def start_point; end
end

class RGeo::Geos::FFILinearRingImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFILineStringMethods
  include ::RGeo::Geos::FFILinearRingMethods
end

module RGeo::Geos::FFILinearRingMethods
  # @return [Boolean]
  def ccw?; end

  def geometry_type; end
end

class RGeo::Geos::FFIMultiLineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::FFIGeometryCollectionMethods
  include ::RGeo::Geos::FFIMultiLineStringMethods
end

module RGeo::Geos::FFIMultiLineStringMethods
  # @return [Boolean]
  def closed?; end

  def coordinates; end
  def geometry_type; end

  # @return [Boolean]
  def is_closed?; end

  def length; end
end

class RGeo::Geos::FFIMultiPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::FFIGeometryCollectionMethods
  include ::RGeo::Geos::FFIMultiPointMethods
end

module RGeo::Geos::FFIMultiPointMethods
  def coordinates; end
  def geometry_type; end
end

class RGeo::Geos::FFIMultiPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::FFIGeometryCollectionMethods
  include ::RGeo::Geos::FFIMultiPolygonMethods
end

module RGeo::Geos::FFIMultiPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def geometry_type; end
end

class RGeo::Geos::FFIPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFIPointMethods
end

module RGeo::Geos::FFIPointMethods
  def coordinates; end
  def geometry_type; end
  def hash; end
  def m; end

  # @return [Boolean]
  def rep_equals?(rhs); end

  def x; end
  def y; end
  def z; end
end

class RGeo::Geos::FFIPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::FFIGeometryMethods
  include ::RGeo::Geos::FFIPolygonMethods
end

module RGeo::Geos::FFIPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def exterior_ring; end
  def geometry_type; end
  def hash; end
  def interior_ring_n(n); end
  def interior_rings; end
  def num_interior_rings; end
  def point_on_surface; end

  # @return [Boolean]
  def rep_equals?(rhs); end
end

RGeo::Geos::FFI_SUPPORT_EXCEPTION = T.let(T.unsafe(nil), LoadError)
RGeo::Geos::JOIN_BEVEL = T.let(T.unsafe(nil), Integer)
RGeo::Geos::JOIN_MITRE = T.let(T.unsafe(nil), Integer)
RGeo::Geos::JOIN_ROUND = T.let(T.unsafe(nil), Integer)

module RGeo::Geos::Utils
  class << self
    def ffi_compute_dimension(geom); end
    def ffi_coord_seq_hash(cs, hash = T.unsafe(nil)); end

    # @return [Boolean]
    def ffi_coord_seqs_equal?(cs1, cs2, check_z); end

    def ffi_supports_prepared_level_1; end
    def ffi_supports_prepared_level_2; end
    def ffi_supports_set_output_dimension; end
    def ffi_supports_unary_union; end
    def marshal_wkb_generator; end
    def psych_wkt_generator; end
  end
end

# A factory for Geos that handles both Z and M.
class RGeo::Geos::ZMFactory
  include ::RGeo::Feature::Factory::Instance
  include ::RGeo::ImplHelper::Utils

  # @return [ZMFactory] a new instance of ZMFactory
  def initialize(opts = T.unsafe(nil)); end

  # Factory equivalence test.
  #
  # @return [Boolean]
  def ==(rhs); end

  # Returns the resolution used by buffer calculations on geometries
  # created by this factory
  def buffer_resolution; end

  # See RGeo::Feature::Factory#collection
  def collection(elems); end

  # See RGeo::Feature::Factory#coord_sys
  def coord_sys; end

  def create_feature(klass, zgeometry, mgeometry); end

  # Psych support
  def encode_with(coder); end

  # Factory equivalence test.
  #
  # @return [Boolean]
  def eql?(rhs); end

  # Standard hash code
  def hash; end

  def init_with(coder); end

  # Returns true if this factory is lenient with MultiPolygon assertions
  #
  # @return [Boolean]
  def lenient_multi_polygon_assertions?; end

  # See RGeo::Feature::Factory#line
  def line(start, stop); end

  # See RGeo::Feature::Factory#line_string
  def line_string(points); end

  # See RGeo::Feature::Factory#linear_ring
  def linear_ring(points); end

  # Returns the m-only factory corresponding to this factory.
  def m_factory; end

  # Marshal support
  def marshal_dump; end

  def marshal_load(data); end
  def marshal_wkb_generator; end
  def marshal_wkb_parser; end

  # See RGeo::Feature::Factory#multi_line_string
  def multi_line_string(elems); end

  # See RGeo::Feature::Factory#multi_point
  def multi_point(elems); end

  # See RGeo::Feature::Factory#multi_polygon
  def multi_polygon(elems); end

  # See RGeo::Feature::Factory#override_cast
  def override_cast(original, ntype, flags); end

  # See RGeo::Feature::Factory#parse_wkb
  def parse_wkb(str); end

  # See RGeo::Feature::Factory#parse_wkt
  def parse_wkt(str); end

  # See RGeo::Feature::Factory#point
  def point(x, y, z = T.unsafe(nil), m = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#polygon
  def polygon(outer_ring, inner_rings = T.unsafe(nil)); end

  # See RGeo::Feature::Factory#proj4
  def proj4; end

  # See RGeo::Feature::Factory#property
  def property(name); end

  def psych_wkt_generator; end
  def psych_wkt_parser; end

  # Returns the SRID of geometries created by this factory.
  def srid; end

  # Returns the z-only factory corresponding to this factory.
  def z_factory; end

  class << self
    # Create a new factory. Returns nil if the GEOS implementation is
    # not supported.
    def create(opts = T.unsafe(nil)); end
  end
end

# :stopdoc:
RGeo::Geos::ZMFactory::TYPE_KLASSES = T.let(T.unsafe(nil), Hash)

class RGeo::Geos::ZMGeometryCollectionImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geos::ZMGeometryCollectionMethods
  include ::Enumerable

  def [](n); end
  def each; end
  def geometry_n(n); end
  def num_geometries; end
  def size; end
end

class RGeo::Geos::ZMGeometryImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Feature::Instance

  def initialize(factory, zgeometry, mgeometry); end

  def *(rhs); end
  def +(rhs); end
  def -(rhs); end

  # @return [Boolean]
  def ==(rhs); end

  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(distance_); end

  # @return [Boolean]
  def contains?(rhs); end

  def convex_hull; end

  # @return [Boolean]
  def crosses?(rhs); end

  def difference(rhs); end
  def dimension; end

  # @return [Boolean]
  def disjoint?(rhs); end

  def distance(rhs); end

  # @return [Boolean]
  def empty?; end

  def encode_with(coder); end
  def envelope; end

  # @return [Boolean]
  def eql?(rhs); end

  # @return [Boolean]
  def equals?(rhs); end

  def factory; end
  def geometry_type; end
  def hash; end
  def init_with(coder); end
  def inspect; end
  def intersection(rhs); end

  # @return [Boolean]
  def intersects?(rhs); end

  # @return [Boolean]
  def is_empty?; end

  # @return [Boolean]
  def is_simple?; end

  def m_geometry; end
  def marshal_dump; end
  def marshal_load(data); end

  # @return [Boolean]
  def overlaps?(rhs); end

  # DEPRECATED
  #
  # @return [Boolean]
  def relate(rhs, pattern); end

  # @return [Boolean]
  def relate?(rhs, pattern); end

  # @return [Boolean]
  def rep_equals?(rhs); end

  # @return [Boolean]
  def simple?; end

  def srid; end
  def sym_difference(rhs); end
  def to_s; end

  # @return [Boolean]
  def touches?(rhs); end

  def union(rhs); end

  # @return [Boolean]
  def within?(rhs); end

  def z_geometry; end

  private

  def copy_state_from(obj); end
end

class RGeo::Geos::ZMLineImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geos::ZMLineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geos::ZMLineStringMethods
  # @return [Boolean]
  def closed?; end

  def coordinates; end
  def end_point; end

  # @return [Boolean]
  def is_closed?; end

  # @return [Boolean]
  def is_ring?; end

  def length; end
  def num_points; end
  def point_n(n); end
  def points; end

  # @return [Boolean]
  def ring?; end

  def start_point; end
end

class RGeo::Geos::ZMLinearRingImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geos::ZMMultiLineStringImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
  include ::RGeo::Geos::ZMMultiLineStringMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geos::ZMMultiLineStringMethods
  # @return [Boolean]
  def closed?; end

  def coordinates; end

  # @return [Boolean]
  def is_closed?; end

  def length; end
end

class RGeo::Geos::ZMMultiPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

class RGeo::Geos::ZMMultiPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::Enumerable
  include ::RGeo::Geos::ZMGeometryCollectionMethods
  include ::RGeo::Geos::ZMMultiPolygonMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geos::ZMMultiPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def point_on_surface; end
end

class RGeo::Geos::ZMPointImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMPointMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geos::ZMPointMethods
  def coordinates; end
  def m; end
  def x; end
  def y; end
  def z; end
end

class RGeo::Geos::ZMPolygonImpl
  include ::RGeo::Feature::Instance
  include ::RGeo::Geos::ZMGeometryMethods
  include ::RGeo::Geos::ZMPolygonMethods
  include ::RGeo::ActiveRecord::GeometryMixin
end

module RGeo::Geos::ZMPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def exterior_ring; end
  def interior_ring_n(n); end
  def interior_rings; end
  def num_interior_rings; end
  def point_on_surface; end
end

module RGeo::ImplHelper; end

module RGeo::ImplHelper::BasicGeometryCollectionMethods
  include ::Enumerable

  def initialize(factory, elements); end

  def [](n); end
  def dimension; end
  def each(&block); end

  # Returns the value of attribute elements.
  def elements; end

  # @return [Boolean]
  def empty?; end

  def geometries; end
  def geometry_n(n); end
  def geometry_type; end
  def hash; end

  # @return [Boolean]
  def is_empty?; end

  def num_geometries; end

  # @return [Boolean]
  def rep_equals?(rhs); end

  private

  def copy_state_from(obj); end
end

module RGeo::ImplHelper::BasicGeometryMethods
  include ::RGeo::Feature::Instance

  def as_binary; end
  def as_text; end
  def encode_with(coder); end

  # Returns the value of attribute factory.
  def factory; end

  # Sets the attribute factory
  #
  # @param value the value to set the attribute factory to.
  def factory=(_arg0); end

  def init_with(coder); end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data); end
  def to_s; end

  private

  def copy_state_from(obj); end
  def validate_geometry; end
end

module RGeo::ImplHelper::BasicLineMethods
  # @raise [Error::InvalidGeometry]
  def initialize(factory, start, stop); end

  def coordinates; end
  def geometry_type; end

  private

  def validate_geometry; end
end

module RGeo::ImplHelper::BasicLineStringMethods
  def initialize(factory, points); end

  def boundary; end

  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def contains?(rhs); end

  def coordinates; end
  def dimension; end

  # @return [Boolean]
  def empty?; end

  def end_point; end
  def geometry_type; end
  def hash; end

  # @return [Boolean]
  def is_closed?; end

  # @return [Boolean]
  def is_empty?; end

  # @return [Boolean]
  def is_ring?; end

  def num_points; end
  def point_n(n); end
  def points; end

  # @return [Boolean]
  def rep_equals?(rhs); end

  # @return [Boolean]
  def ring?; end

  def start_point; end

  private

  # @return [Boolean]
  def between_coordinate?(coord, start_coord, end_coord); end

  # @return [Boolean]
  def contains_point?(point); end

  def copy_state_from(obj); end

  # @return [Boolean]
  def point_collinear?(a, b, c); end

  # @return [Boolean]
  def point_intersect_segment?(point, start_point, end_point); end

  def validate_geometry; end
end

module RGeo::ImplHelper::BasicLinearRingMethods
  # @return [Boolean]
  def ccw?; end

  def geometry_type; end

  private

  def validate_geometry; end
end

module RGeo::ImplHelper::BasicMultiLineStringMethods
  def initialize(factory, elements); end

  def boundary; end

  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def contains?(rhs); end

  def coordinates; end
  def geometry_type; end

  # @return [Boolean]
  def is_closed?; end

  def length; end

  private

  def add_boundary(hash, point); end
end

module RGeo::ImplHelper::BasicMultiPointMethods
  def initialize(factory, elements); end

  def boundary; end
  def coordinates; end
  def geometry_type; end
end

module RGeo::ImplHelper::BasicMultiPolygonMethods
  def initialize(factory, elements); end

  def area; end
  def boundary; end

  # @return [Boolean]
  def contains?(rhs); end

  def coordinates; end
  def geometry_type; end
end

module RGeo::ImplHelper::BasicPointMethods
  def initialize(factory, x, y, *extra); end

  def boundary; end
  def convex_hull; end
  def coordinates; end
  def dimension; end

  # @return [Boolean]
  def empty?; end

  def envelope; end

  # @return [Boolean]
  def equals?(rhs); end

  def geometry_type; end
  def hash; end

  # @return [Boolean]
  def is_empty?; end

  # @return [Boolean]
  def is_simple?; end

  def m; end

  # @return [Boolean]
  def rep_equals?(rhs); end

  # @return [Boolean]
  def simple?; end

  def x; end
  def y; end
  def z; end

  private

  def copy_state_from(obj); end
end

module RGeo::ImplHelper::BasicPolygonMethods
  def initialize(factory, exterior_ring, interior_rings); end

  def boundary; end

  # @return [Boolean]
  def contains?(rhs); end

  def coordinates; end
  def dimension; end

  # @return [Boolean]
  def empty?; end

  def exterior_ring; end
  def geometry_type; end
  def hash; end
  def interior_ring_n(n); end
  def interior_rings; end

  # @return [Boolean]
  def is_empty?; end

  def num_interior_rings; end

  # @return [Boolean]
  def rep_equals?(rhs); end

  private

  # @return [Boolean]
  def contains_point?(point); end

  def copy_state_from(obj); end

  # @return [Boolean]
  def ring_encloses_point?(ring, point, on_border_return: T.unsafe(nil)); end
end

module RGeo::ImplHelper::Math; end
RGeo::ImplHelper::Math::DEGREES_PER_RADIAN = T.let(T.unsafe(nil), Float)
RGeo::ImplHelper::Math::RADIANS_PER_DEGREE = T.let(T.unsafe(nil), Float)

module RGeo::ImplHelper::Utils
  private

  def symbolize_hash(hash); end
end

RGeo::VERSION = T.let(T.unsafe(nil), String)
module RGeo::WKRep; end

# This class provides the functionality of serializing a geometry as
# WKB (well-known binary) format. You may also customize the
# serializer to generate PostGIS EWKB extensions to the output, or to
# follow the Simple Features Specification 1.2 extensions for Z and M
# coordinates.
#
# To use this class, create an instance with the desired settings and
# customizations, and call the generate method.
#
# === Configuration options
#
# The following options are recognized. These can be passed to the
# constructor, or set on the object afterwards.
#
# [<tt>:type_format</tt>]
#   The format for type codes. Possible values are <tt>:wkb11</tt>,
#   indicating SFS 1.1 WKB (i.e. no Z or M values); <tt>:ewkb</tt>,
#   indicating the PostGIS EWKB extensions (i.e. Z and M presence
#   flagged by the two high bits of the type code, and support for
#   embedded SRID); or <tt>:wkb12</tt> (indicating SFS 1.2 WKB
#   (i.e. Z and M presence flagged by adding 1000 and/or 2000 to
#   the type code.) Default is <tt>:wkb11</tt>.
# [<tt>:emit_ewkb_srid</tt>]
#   If true, embed the SRID in the toplevel geometry. Available only
#   if <tt>:type_format</tt> is <tt>:ewkb</tt>. Default is false.
# [<tt>:hex_format</tt>]
#   If true, output a hex string instead of a byte string.
#   Default is false.
# [<tt>:little_endian</tt>]
#   If true, output little endian (NDR) byte order. If false, output
#   big endian (XDR), or network byte order. Default is false.
class RGeo::WKRep::WKBGenerator
  # Create and configure a WKB generator. See the WKBGenerator
  # documentation for the options that can be passed.
  #
  # @return [WKBGenerator] a new instance of WKBGenerator
  def initialize(opts = T.unsafe(nil)); end

  # Returns whether SRID is embedded. See WKBGenerator for details.
  #
  # @return [Boolean]
  def emit_ewkb_srid?; end

  # Generate and return the WKB format for the given geometry object,
  # according to the current settings.
  def generate(obj); end

  # Returns whether output is converted to hex.
  # See WKBGenerator for details.
  #
  # @return [Boolean]
  def hex_format?; end

  # Returns whether output is little-endian (NDR).
  # See WKBGenerator for details.
  #
  # @return [Boolean]
  def little_endian?; end

  def properties; end

  # Returns the format for type codes. See WKBGenerator for details.
  def type_format; end

  private

  def emit_byte(value); end
  def emit_doubles(array); end
  def emit_integer(value); end
  def emit_line_string_coords(obj); end
  def finish_emitter; end
  def generate_feature(obj, toplevel = T.unsafe(nil)); end
  def point_coords(obj, array = T.unsafe(nil)); end
  def start_emitter; end
end

# :stopdoc:
RGeo::WKRep::WKBGenerator::TYPE_CODES = T.let(T.unsafe(nil), Hash)

# This class provides the functionality of parsing a geometry from
# WKB (well-known binary) format. You may also customize the parser
# to recognize PostGIS EWKB extensions to the input, or Simple
# Features Specification 1.2 extensions for Z and M coordinates.
#
# To use this class, create an instance with the desired settings and
# customizations, and call the parse method.
#
# === Configuration options
#
# You must provide each parser with an RGeo::Feature::FactoryGenerator.
# It should understand the configuration options <tt>:srid</tt>,
# <tt>:has_z_coordinate</tt>, and <tt>:has_m_coordinate</tt>.
# You may also pass a specific RGeo::Feature::Factory, or nil to
# specify the default Cartesian FactoryGenerator.
#
# The following additional options are recognized. These can be passed
# to the constructor, or set on the object afterwards.
#
# [<tt>:support_ewkb</tt>]
#   Activate support for PostGIS EWKB type codes, which use high
#   order bits in the type code to signal the presence of Z, M, and
#   SRID values in the data. Default is false.
# [<tt>:support_wkb12</tt>]
#   Activate support for SFS 1.2 extensions to the type codes, which
#   use values greater than 1000 to signal the presence of Z and M
#   values in the data. SFS 1.2 types such as triangle, tin, and
#   polyhedralsurface are NOT yet supported. Default is false.
# [<tt>:ignore_extra_bytes</tt>]
#   If true, extra bytes at the end of the data are ignored. If
#   false (the default), extra bytes will trigger a parse error.
# [<tt>:default_srid</tt>]
#   A SRID to pass to the factory generator if no SRID is present in
#   the input. Defaults to nil (i.e. don't specify a SRID).
class RGeo::WKRep::WKBParser
  # Create and configure a WKB parser. See the WKBParser
  # documentation for the options that can be passed.
  #
  # @return [WKBParser] a new instance of WKBParser
  def initialize(factory_generator = T.unsafe(nil), opts = T.unsafe(nil)); end

  # If this parser was given an exact factory, returns it; otherwise
  # returns nil.
  def exact_factory; end

  # Returns the factory generator. See WKBParser for details.
  def factory_generator; end

  # Returns true if this parser ignores extra bytes.
  # See WKBParser for details.
  #
  # @return [Boolean]
  def ignore_extra_bytes?; end

  # Parse the given binary data or hexadecimal string, and return a
  # geometry object.
  #
  # The #parse_hex method is a synonym, present for historical
  # reasons but deprecated. Use #parse instead.
  def parse(data); end

  # Parse the given binary data or hexadecimal string, and return a
  # geometry object.
  #
  # The #parse_hex method is a synonym, present for historical
  # reasons but deprecated. Use #parse instead.
  def parse_hex(data); end

  def properties; end

  # Returns true if this parser supports EWKB.
  # See WKBParser for details.
  #
  # @return [Boolean]
  def support_ewkb?; end

  # Returns true if this parser supports SFS 1.2 extensions.
  # See WKBParser for details.
  #
  # @return [Boolean]
  def support_wkb12?; end

  private

  def bytes_remaining; end
  def get_byte; end
  def get_doubles(little_endian, count); end
  def get_integer(little_endian); end
  def parse_line_string(little_endian); end
  def parse_object(contained); end
  def start_scanner(data); end
end

# This class provides the functionality of serializing a geometry as
# WKT (well-known text) format. You may also customize the serializer
# to generate PostGIS EWKT extensions to the output, or to follow the
# Simple Features Specification 1.2 extensions for Z and M.
#
# To use this class, create an instance with the desired settings and
# customizations, and call the generate method.
#
# === Configuration options
#
# The following options are recognized. These can be passed to the
# constructor, or set on the object afterwards.
#
# [<tt>:tag_format</tt>]
#   The format for tags. Possible values are <tt>:wkt11</tt>,
#   indicating SFS 1.1 WKT (i.e. no Z or M markers in the tags) but
#   with Z and/or M values added in if they are present;
#   <tt>:wkt11_strict</tt>, indicating SFS 1.1 WKT with Z and M
#   dropped from the output (since WKT strictly does not support
#   the Z or M dimensions); <tt>:ewkt</tt>, indicating the PostGIS
#   EWKT extensions (i.e. "M" appended to tag names if M but not
#   Z is present); or <tt>:wkt12</tt>, indicating SFS 1.2 WKT
#   tags that indicate the presence of Z and M in a separate token.
#   Default is <tt>:wkt11</tt>.
#   This option can also be specified as <tt>:type_format</tt>.
# [<tt>:emit_ewkt_srid</tt>]
#   If true, embed the SRID of the toplevel geometry. Available only
#   if <tt>:tag_format</tt> is <tt>:ewkt</tt>. Default is false.
# [<tt>:square_brackets</tt>]
#   If true, uses square brackets rather than parentheses.
#   Default is false.
# [<tt>:convert_case</tt>]
#   Possible values are <tt>:upper</tt>, which changes all letters
#   in the output to ALL CAPS; <tt>:lower</tt>, which changes all
#   letters to lower case; or nil, indicating no case changes from
#   the default (which is not specified exactly, but is chosen by the
#   generator to emphasize readability.) Default is nil.
class RGeo::WKRep::WKTGenerator
  # Create and configure a WKT generator. See the WKTGenerator
  # documentation for the options that can be passed.
  #
  # @return [WKTGenerator] a new instance of WKTGenerator
  def initialize(opts = T.unsafe(nil)); end

  # Returns the case for output. See WKTGenerator for details.
  def convert_case; end

  # Returns whether SRID is embedded. See WKTGenerator for details.
  #
  # @return [Boolean]
  def emit_ewkt_srid?; end

  # Generate and return the WKT format for the given geometry object,
  # according to the current settings.
  def generate(obj); end

  def properties; end

  # Returns whether square brackets rather than parens are output.
  # See WKTGenerator for details.
  #
  # @return [Boolean]
  def square_brackets?; end

  # Returns the format for type tags. See WKTGenerator for details.
  def tag_format; end

  # Returns the format for type tags. See WKTGenerator for details.
  def type_format; end

  private

  def generate_coords(obj); end
  def generate_feature(obj, toplevel = T.unsafe(nil)); end
  def generate_geometry_collection(obj); end
  def generate_line_string(obj); end
  def generate_multi_line_string(obj); end
  def generate_multi_point(obj); end
  def generate_multi_polygon(obj); end
  def generate_point(obj); end
  def generate_polygon(obj); end
end

# This class provides the functionality of parsing a geometry from
# WKT (well-known text) format. You may also customize the parser
# to recognize PostGIS EWKT extensions to the input, or Simple
# Features Specification 1.2 extensions for Z and M coordinates.
#
# To use this class, create an instance with the desired settings and
# customizations, and call the parse method.
#
# === Configuration options
#
# You must provide each parser with an RGeo::Feature::FactoryGenerator.
# It should understand the configuration options <tt>:srid</tt>,
# <tt>:has_z_coordinate</tt>, and <tt>:has_m_coordinate</tt>.
# You may also pass a specific RGeo::Feature::Factory, or nil to
# specify the default Cartesian FactoryGenerator.
#
# The following additional options are recognized. These can be passed
# to the constructor, or set on the object afterwards.
#
# [<tt>:support_ewkt</tt>]
#   Activate support for PostGIS EWKT type tags, which appends an "M"
#   to tags to indicate the presence of M but not Z, and also
#   recognizes the SRID prefix. Default is false.
# [<tt>:support_wkt12</tt>]
#   Activate support for SFS 1.2 extensions to the type codes, which
#   use a "M", "Z", or "ZM" token to signal the presence of Z and M
#   values in the data. SFS 1.2 types such as triangle, tin, and
#   polyhedralsurface are NOT yet supported. Default is false.
# [<tt>:strict_wkt11</tt>]
#   If true, parsing will proceed in SFS 1.1 strict mode, which
#   disallows any values other than X or Y. This has no effect if
#   support_ewkt or support_wkt12 are active. Default is false.
# [<tt>:ignore_extra_tokens</tt>]
#   If true, extra tokens at the end of the data are ignored. If
#   false (the default), extra tokens will trigger a parse error.
# [<tt>:default_srid</tt>]
#   A SRID to pass to the factory generator if no SRID is present in
#   the input. Defaults to nil (i.e. don't specify a SRID).
class RGeo::WKRep::WKTParser
  # Create and configure a WKT parser. See the WKTParser
  # documentation for the options that can be passed.
  #
  # @return [WKTParser] a new instance of WKTParser
  def initialize(factory_generator = T.unsafe(nil), opts = T.unsafe(nil)); end

  # If this parser was given an exact factory, returns it; otherwise
  # returns nil.
  def exact_factory; end

  # Returns the factory generator. See WKTParser for details.
  def factory_generator; end

  # Returns true if this parser ignores extra tokens.
  # See WKTParser for details.
  #
  # @return [Boolean]
  def ignore_extra_tokens?; end

  # Parse the given string, and return a geometry object.
  def parse(str); end

  def properties; end

  # Returns true if this parser strictly adheres to WKT 1.1.
  # See WKTParser for details.
  #
  # @return [Boolean]
  def strict_wkt11?; end

  # Returns true if this parser supports EWKT.
  # See WKTParser for details.
  #
  # @return [Boolean]
  def support_ewkt?; end

  # Returns true if this parser supports SFS 1.2 extensions.
  # See WKTParser for details.
  #
  # @return [Boolean]
  def support_wkt12?; end

  private

  def check_factory_support; end
  def clean_scanner; end
  def ensure_factory; end
  def expect_token_type(type); end
  def next_token; end
  def parse_coords; end
  def parse_geometry_collection; end
  def parse_line_string; end
  def parse_multi_line_string; end
  def parse_multi_point; end
  def parse_multi_polygon; end
  def parse_point(convert_empty = T.unsafe(nil)); end
  def parse_polygon; end
  def parse_type_tag; end
  def start_scanner(str); end
end
