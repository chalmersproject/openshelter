# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `can_has_validations` gem.
# Please instead update this file by running `bin/tapioca gem can_has_validations`.

# validates each value of a hash attribute
#
# by default only allows the first error per validator, regardless of how many
# values fail validation. this improves performance and avoids a bunch of
# repeating error messages.
# use `multiple_errors: true` on :hash_values or a single sub-validator to
# enable the full set of errors. this is potentially useful if each error
# message will vary based upon each hash value.
#
# the :if, :unless, and :on conditionals are not supported on sub-validators,
# but do work as normal on the :hash_values validator itself.
#
# usage:
#   validates :subjects,
#     hash_values: {
#       length: 3..100,
#       # multiple_errors: true
#     }
module ActiveModel
  extend ::ActiveSupport::Autoload

  class << self
    def eager_load!; end

    # Returns the currently loaded version of \Active \Model as a <tt>Gem::Version</tt>.
    def gem_version; end

    # Returns the currently loaded version of \Active \Model as a <tt>Gem::Version</tt>.
    def version; end
  end
end

# write-once, read-many
#   Allows a value to be set to a non-nil value once, and then makes it immutable.
#   Combine with existence: true to accomplish the same thing as attr_readonly,
#   except with error messages (instead of silently refusing to save the change).
# eg: validates :user_id, write_once: true
#   Optionally refuses changing from nil => non-nil, always making field immutable.
# eg: validates :source, write_once: {immutable_nil: true}
module ActiveModel::Validations
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods

  # Returns the +Errors+ object that holds all information about attribute
  # error messages.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name
  #   end
  #
  #   person = Person.new
  #   person.valid? # => false
  #   person.errors # => #<ActiveModel::Errors:0x007fe603816640 @messages={name:["can't be blank"]}>
  def errors; end

  # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
  # added, +false+ otherwise.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name
  #   end
  #
  #   person = Person.new
  #   person.name = ''
  #   person.invalid? # => true
  #   person.name = 'david'
  #   person.invalid? # => false
  #
  # Context can optionally be supplied to define which callbacks to test
  # against (the context is defined on the validations using <tt>:on</tt>).
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name, on: :new
  #   end
  #
  #   person = Person.new
  #   person.invalid?       # => false
  #   person.invalid?(:new) # => true
  #
  # @return [Boolean]
  def invalid?(context = T.unsafe(nil)); end

  # Hook method defining how an attribute value should be retrieved. By default
  # this is assumed to be an instance named after the attribute. Override this
  # method in subclasses should you need to retrieve the value for a given
  # attribute differently:
  #
  #   class MyClass
  #     include ActiveModel::Validations
  #
  #     def initialize(data = {})
  #       @data = data
  #     end
  #
  #     def read_attribute_for_validation(key)
  #       @data[key]
  #     end
  #   end
  def read_attribute_for_validation(*_arg0); end

  # Runs all the specified validations and returns +true+ if no errors were
  # added otherwise +false+.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name
  #   end
  #
  #   person = Person.new
  #   person.name = ''
  #   person.valid? # => false
  #   person.name = 'david'
  #   person.valid? # => true
  #
  # Context can optionally be supplied to define which callbacks to test
  # against (the context is defined on the validations using <tt>:on</tt>).
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name, on: :new
  #   end
  #
  #   person = Person.new
  #   person.valid?       # => true
  #   person.valid?(:new) # => false
  #
  # @return [Boolean]
  def valid?(context = T.unsafe(nil)); end

  # Runs all the specified validations and returns +true+ if no errors were
  # added otherwise +false+.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name
  #   end
  #
  #   person = Person.new
  #   person.name = ''
  #   person.valid? # => false
  #   person.name = 'david'
  #   person.valid? # => true
  #
  # Context can optionally be supplied to define which callbacks to test
  # against (the context is defined on the validations using <tt>:on</tt>).
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name, on: :new
  #   end
  #
  #   person = Person.new
  #   person.valid?       # => true
  #   person.valid?(:new) # => false
  #
  # @return [Boolean]
  def validate(context = T.unsafe(nil)); end

  # Runs all the validations within the specified context. Returns +true+ if
  # no errors are found, raises +ValidationError+ otherwise.
  #
  # Validations with no <tt>:on</tt> option will run no matter the context. Validations with
  # some <tt>:on</tt> option will only run in the specified context.
  def validate!(context = T.unsafe(nil)); end

  # Passes the record off to the class or classes specified and allows them
  # to add errors based on more complex conditions.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     validate :instance_validations
  #
  #     def instance_validations
  #       validates_with MyValidator
  #     end
  #   end
  #
  # Please consult the class method documentation for more information on
  # creating your own validator.
  #
  # You may also pass it multiple classes, like so:
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     validate :instance_validations, on: :create
  #
  #     def instance_validations
  #       validates_with MyValidator, MyOtherValidator
  #     end
  #   end
  #
  # Standard configuration options (<tt>:on</tt>, <tt>:if</tt> and
  # <tt>:unless</tt>), which are available on the class version of
  # +validates_with+, should instead be placed on the +validates+ method
  # as these are applied and tested in the callback.
  #
  # If you pass any additional configuration options, they will be passed
  # to the class and available as +options+, please refer to the
  # class version of this method for more information.
  def validates_with(*args, &block); end

  private

  # Clean the +Errors+ object if instance is duped.
  def initialize_dup(other); end

  # @raise [ValidationError]
  def raise_validation_error; end

  def run_validations!; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

class ActiveModel::Validations::AfterValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
end

class ActiveModel::Validations::ArrayValidator < ::ActiveModel::EachValidator
  # @raise [ArgumentError]
  # @return [ArrayValidator] a new instance of ArrayValidator
  def initialize(options); end

  def validate_each(record, attribute, array_values); end
  def validate_one(validator, record, attribute, value); end

  # Returns the value of attribute validators.
  def validators; end

  private

  # copied from active_model/validations/validates.rb
  def _parse_validates_options(options); end

  def count_errors(record); end
end

module ActiveModel::Validations::ArrayValidator::DefaultKeys
  private

  # When creating custom validators, it might be useful to be able to specify
  # additional default keys. This can be done by overwriting this method.
  def _validates_default_keys; end
end

class ActiveModel::Validations::BeforeValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
end

ActiveModel::Validations::EmailValidator = EmailValidator

class ActiveModel::Validations::ExistenceValidator < ::ActiveModel::Validations::PresenceValidator
  def validate(record); end
end

class ActiveModel::Validations::GrandparentValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, association); end
end

class ActiveModel::Validations::HashKeysValidator < ::ActiveModel::Validations::ArrayValidator
  def validate_each(record, attribute, hash); end
end

class ActiveModel::Validations::HashValuesValidator < ::ActiveModel::Validations::ArrayValidator
  # @return [HashValuesValidator] a new instance of HashValuesValidator
  def initialize(options); end

  def validate_each(record, attribute, hash); end
  def validate_one(validator, record, attribute, key_and_value); end
end

module ActiveModel::Validations::HashValuesValidator::HashValidatorKey
  def hash_validator_key; end
  def hash_validator_key=(v); end
end

class ActiveModel::Validations::HostnameValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
end

ActiveModel::Validations::HostnameValidator::FINAL_LABEL_REGEXP = T.let(T.unsafe(nil), Regexp)
ActiveModel::Validations::HostnameValidator::LABEL_REGEXP = T.let(T.unsafe(nil), Regexp)
ActiveModel::Validations::HostnameValidator::RESERVED_OPTIONS = T.let(T.unsafe(nil), Array)

class ActiveModel::Validations::IpaddrValidator < ::ActiveModel::EachValidator
  # @return [IpaddrValidator] a new instance of IpaddrValidator
  def initialize(options); end

  def validate_each(record, attribute, value); end

  private

  # @return [Boolean]
  def ip_within_block?(ip, blk); end

  def normalize_within(val, key); end
  def resolve_array(record, val); end
end

class ActiveModel::Validations::UrlValidator < ::ActiveModel::EachValidator
  def initialize(options); end

  def validate_each(record, attribute, value); end

  protected

  def filtered_options(value); end
  def validate_url(record, attribute, value, schemes); end
end

ActiveModel::Validations::UrlValidator::RESERVED_OPTIONS = T.let(T.unsafe(nil), Array)

class ActiveModel::Validations::WriteOnceValidator < ::ActiveModel::EachValidator
  # as of ActiveModel 4, allow_nil: true causes a change from a value back to
  #   nil to be allowed. prevent this.
  def validate(record); end

  def validate_each(record, attribute, _); end
end
