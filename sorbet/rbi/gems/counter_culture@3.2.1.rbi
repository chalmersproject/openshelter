# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `counter_culture` gem.
# Please instead update this file by running `bin/tapioca gem counter_culture`.

module CounterCulture
  def batch_size; end
  def batch_size=(val); end

  class << self
    def batch_size; end
    def batch_size=(val); end

    # @yield [_self]
    # @yieldparam _self [CounterCulture] the object that the method was called on
    def config; end
  end
end

class CounterCulture::Counter
  # @return [Counter] a new instance of Counter
  def initialize(model, relation, options); end

  # @return [Boolean]
  def attribute_changed?(obj, attr); end

  # increments or decrements a counter cache
  #
  # options:
  #   :increment => true to increment, false to decrement
  #   :relation => which relation to increment the count on,
  #   :counter_cache_name => the column name of the counter cache
  #   :counter_column => overrides :counter_cache_name
  #   :delta_column => override the default count delta (1) with the value of this column in the counted record
  #   :was => whether to get the current value or the old value of the
  #      first part of the relation
  #   :with_papertrail => update the column via Papertrail touch_with_version method
  def change_counter_cache(obj, options); end

  def column_names; end
  def counter_cache_name; end

  # Gets the name of the counter cache for a specific object
  #
  # obj: object to calculate the counter cache name for
  # cache_name_finder: object used to calculate the cache name
  def counter_cache_name_for(obj); end

  # Gets the delta magnitude of the counter cache for a specific object
  #
  # obj: object to calculate the counter cache name for
  def counter_delta_magnitude_for(obj); end

  def delta_column; end
  def delta_magnitude; end
  def execute_after_commit; end
  def execute_now_or_after_commit(obj, &block); end

  # @return [Boolean]
  def first_level_relation_changed?(instance); end

  # gets the foreign key name of the relation. will look at the first
  # level only -- i.e., if passed an array will consider only its
  # first element
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  def first_level_relation_foreign_key; end

  def first_level_relation_foreign_type; end

  # gets the value of the foreign key on the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  # was: whether to get the current or past value from ActiveRecord;
  #   pass true to get the past value, false or nothing to get the
  #   current value
  def foreign_key_value(obj, relation, was = T.unsafe(nil)); end

  def foreign_key_values; end

  # the string to pass to order() in order to sort by primary key
  def full_primary_key(klass); end

  def model; end

  # @return [Boolean]
  def polymorphic?; end

  def previous_model(obj); end
  def relation; end

  # gets the foreign key name of the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  def relation_foreign_key(relation); end

  # gets the class of the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  # source [optional]: the source object,
  #   only needed for polymorphic associations,
  #   probably only works with a single relation (symbol, or array of 1 symbol)
  # was: boolean
  #   we're actually looking for the old value -- only can change for polymorphic relations
  def relation_klass(relation, source: T.unsafe(nil), was: T.unsafe(nil)); end

  # gets the primary key name of the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  # source[optional]: the model instance that the relationship is linked from,
  #   only needed for polymorphic associations,
  #   probably only works with a single relation (symbol, or array of 1 symbol)
  # was: boolean
  #   we're actually looking for the old value -- only can change for polymorphic relations
  def relation_primary_key(relation, source: T.unsafe(nil), was: T.unsafe(nil)); end

  # gets the reflect object on the given relation
  #
  # relation: a symbol or array of symbols; specifies the relation
  #   that has the counter cache column
  def relation_reflect(relation); end

  def touch; end

  private

  def attribute_was(obj, attr); end
end

CounterCulture::Counter::ACTIVE_RECORD_VERSION = T.let(T.unsafe(nil), Gem::Version)
CounterCulture::Counter::CONFIG_OPTIONS = T.let(T.unsafe(nil), Array)

module CounterCulture::Extensions
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::CounterCulture::Extensions::ClassMethods

  private

  # called by after_create callback
  def _update_counts_after_create; end

  # called by after_destroy callback
  def _update_counts_after_destroy; end

  # called by after_update callback
  def _update_counts_after_update; end

  # check if record is soft-deleted
  #
  # @return [Boolean]
  def destroyed_for_counter_culture?; end
end

module CounterCulture::Extensions::ClassMethods
  # this holds all configuration data
  def after_commit_counter_cache; end

  # called to configure counter caches
  def counter_culture(relation, options = T.unsafe(nil)); end

  # checks all of the declared counter caches on this class for correctnes based
  # on original data; if the counter cache is incorrect, sets it to the correct
  # count
  #
  # options:
  #   { :exclude => list of relations to skip when fixing counts,
  #     :only => only these relations will have their counts fixed,
  #     :column_name => only this column will have its count fixed
  #     :polymorphic_classes => specify the class(es) to update in polymorphic associations }
  # returns: a list of fixed record as an array of hashes of the form:
  #   { :entity => which model the count was fixed on,
  #     :id => the id of the model that had the incorrect count,
  #     :what => which column contained the incorrect count,
  #     :wrong => the previously saved, incorrect count,
  #     :right => the newly fixed, correct count }
  def counter_culture_fix_counts(options = T.unsafe(nil)); end
end

class CounterCulture::Reconciler
  # @return [Reconciler] a new instance of Reconciler
  def initialize(counter, options = T.unsafe(nil)); end

  # Returns the value of attribute changes.
  def changes; end

  def column_names(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute counter.
  def counter; end

  def counter_cache_name(*_arg0, **_arg1, &_arg2); end
  def delta_column(*_arg0, **_arg1, &_arg2); end
  def delta_magnitude(*_arg0, **_arg1, &_arg2); end
  def execute_after_commit(*_arg0, **_arg1, &_arg2); end
  def foreign_key_values(*_arg0, **_arg1, &_arg2); end
  def full_primary_key(*_arg0, **_arg1, &_arg2); end
  def model(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute options.
  def options; end

  def polymorphic?(*_arg0, **_arg1, &_arg2); end
  def reconcile!; end
  def relation(*_arg0, **_arg1, &_arg2); end
  def relation_reflect(*_arg0, **_arg1, &_arg2); end
  def touch(*_arg0, **_arg1, &_arg2); end

  private

  def associated_model_class; end
  def associated_model_classes; end
  def polymorphic_associated_model_classes; end
end

CounterCulture::Reconciler::ACTIVE_RECORD_VERSION = T.let(T.unsafe(nil), Gem::Version)

class CounterCulture::Reconciler::Reconciliation
  # @return [Reconciliation] a new instance of Reconciliation
  def initialize(counter, changes_holder, options, relation_class); end

  def column_names(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute counter.
  def counter; end

  def counter_cache_name(*_arg0, **_arg1, &_arg2); end
  def delta_column(*_arg0, **_arg1, &_arg2); end
  def delta_magnitude(*_arg0, **_arg1, &_arg2); end
  def execute_after_commit(*_arg0, **_arg1, &_arg2); end
  def foreign_key_values(*_arg0, **_arg1, &_arg2); end
  def full_primary_key(*_arg0, **_arg1, &_arg2); end
  def model(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute options.
  def options; end

  def perform; end
  def polymorphic?(*_arg0, **_arg1, &_arg2); end
  def relation(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute relation_class.
  def relation_class; end

  def relation_reflect(*_arg0, **_arg1, &_arg2); end
  def touch(*_arg0, **_arg1, &_arg2); end

  private

  def count_select; end
  def join_clauses(where); end
  def log(message); end

  # @return [Boolean]
  def log?; end

  def log_without_newline(message); end
  def parameterize(string); end

  # This is only needed in relatively unusal cases, for example if you are
  # using Postgres with schema-namespaced tables. But then it's required,
  # and otherwise it's just a no-op, so why not do it?
  def quote_table_name(table_name); end

  def self_table_name; end

  # keep track of what we fixed, e.g. for a notification email
  def track_change(record, column_name, count); end

  def update_count_for_batch(column_name, records); end
end

CounterCulture::VERSION = T.let(T.unsafe(nil), String)
